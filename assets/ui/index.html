<!--
This UI renders the mini power HUD, floating gain popups, and an interact prompt for training.
-->

<script>
  // Register SceneUI templates as soon as hytopia is available
  // This ensures templates are available when server creates SceneUIs
  (function registerSceneUITemplates() {
    if (window.__trainingSceneTemplatesRegistered) return;
    
    // Wait for hytopia to be available
    if (typeof hytopia === 'undefined') {
      setTimeout(registerSceneUITemplates, 10);
      return;
    }
    
    window.__trainingSceneTemplatesRegistered = true;

    hytopia.registerSceneUITemplate('training:prompt', (_id, onState) => {
      const root = document.createElement('div');
      root.className = 'scene-training-prompt visible'; // Start visible

      // Icon (explosion/starburst)
      const icon = document.createElement('div');
      icon.className = 'scene-training-prompt__icon';
      icon.textContent = 'üí•';
      root.appendChild(icon);

      const copy = document.createElement('div');
      copy.className = 'scene-training-prompt__copy';
      root.appendChild(copy);

      // Power requirement
      const requirementText = document.createElement('div');
      requirementText.className = 'scene-training-prompt__requirement';
      requirementText.textContent = '0 Required';
      copy.appendChild(requirementText);

      // OR separator
      const orText = document.createElement('div');
      orText.className = 'scene-training-prompt__or';
      orText.textContent = 'OR';
      copy.appendChild(orText);

      // Rebirth requirement
      const rebirthText = document.createElement('div');
      rebirthText.className = 'scene-training-prompt__rebirth';
      rebirthText.textContent = '0 Rebirths';
      copy.appendChild(rebirthText);

      // Power gain
      const powerGainText = document.createElement('div');
      powerGainText.className = 'scene-training-prompt__power-gain';
      powerGainText.textContent = '+1 Power';
      copy.appendChild(powerGainText);

      // Handle state updates
      onState(state => {
        const data = state || {};
        
        if (data.requirementText !== undefined) {
          requirementText.textContent = data.requirementText;
        }
        if (data.rebirthText !== undefined) {
          rebirthText.textContent = data.rebirthText;
        }
        if (data.powerGainText !== undefined) {
          powerGainText.textContent = data.powerGainText;
        }
        
        // Toggle visibility based on state
        if (data.visible === false) {
          root.classList.remove('visible');
        } else {
          root.classList.add('visible');
        }
        
        // Toggle locked state
        if (data.canTrain === false) {
          root.classList.add('locked');
        } else {
          root.classList.remove('locked');
        }
      });

      return root;
    });

    hytopia.registerSceneUITemplate('egg:prompt', (_id, onState) => {
      const root = document.createElement('div');
      root.className = 'scene-egg-prompt visible';

      const icon = document.createElement('div');
      icon.className = 'scene-egg-prompt__icon';
      icon.textContent = 'ü•ö';
      root.appendChild(icon);

      const copy = document.createElement('div');
      copy.className = 'scene-egg-prompt__copy';
      root.appendChild(copy);

      const title = document.createElement('div');
      title.className = 'scene-egg-prompt__title';
      title.textContent = 'Egg';
      copy.appendChild(title);

      const subtitle = document.createElement('div');
      subtitle.className = 'scene-egg-prompt__subtitle';
      subtitle.textContent = 'Open eggs here';
      copy.appendChild(subtitle);

      const cost = document.createElement('div');
      cost.className = 'scene-egg-prompt__cost';
      cost.textContent = '0 gold';
      copy.appendChild(cost);

      onState(state => {
        const data = state || {};
        if (data.title !== undefined) title.textContent = data.title;
        if (data.subtitle !== undefined) {
          subtitle.textContent = data.subtitle;
          // Hide subtitle if empty so this looks like the reference (name + cost only).
          subtitle.style.display = data.subtitle ? 'block' : 'none';
        }
        if (data.costText !== undefined) cost.textContent = data.costText;

        if (data.visible === false) root.classList.remove('visible');
        else root.classList.add('visible');
      });

      return root;
    });

  })();

  window.addEventListener('DOMContentLoaded', () => {
    console.log('[UI] DOMContentLoaded, setting up UI');
    setupMobileButtons();
    setupRightClickCamera();
    setupPowerHud();
    setupMerchantUI();
    setupMineResetUpgradeUI();
    setupGemTraderUI();
    setupEggStationUI();
    setupKeyboardDebug();
    console.log('[UI] UI setup complete');
  });

  // Also try setting up immediately if DOM is already loaded
  if (document.readyState === 'loading') {
    console.log('[UI] DOM is still loading, waiting for DOMContentLoaded');
  } else {
    console.log('[UI] DOM already loaded, setting up UI immediately');
    setupMobileButtons();
    setupRightClickCamera();
    setupPowerHud();
    setupMerchantUI();
    setupMineResetUpgradeUI();
    setupGemTraderUI();
    setupEggStationUI();
    setupKeyboardDebug();
  }

  /**
   * Debug keyboard input to see what's blocking movement
   */
  function setupKeyboardDebug() {
    // Log all keydown events
    window.addEventListener('keydown', (e) => {
      const wasdKeys = ['KeyW', 'KeyA', 'KeyS', 'KeyD'];
      if (wasdKeys.includes(e.code)) {
        console.log('[DEBUG] Keydown:', e.code, {
          defaultPrevented: e.defaultPrevented,
          target: e.target?.tagName,
          targetId: e.target?.id,
          targetClass: e.target?.className,
          isTrusted: e.isTrusted
        });
      }
    }, true); // Use capture phase to catch early

    // Log all keyup events
    window.addEventListener('keyup', (e) => {
      const wasdKeys = ['KeyW', 'KeyA', 'KeyS', 'KeyD'];
      if (wasdKeys.includes(e.code)) {
        console.log('[DEBUG] Keyup:', e.code, {
          defaultPrevented: e.defaultPrevented,
          target: e.target?.tagName
        });
      }
    }, true);

    // Check if hytopia is available and can receive input
    if (typeof hytopia !== 'undefined') {
      console.log('[DEBUG] Hytopia available:', {
        hasPressInput: typeof hytopia.pressInput === 'function',
        hasLockPointer: typeof hytopia.lockPointer === 'function'
      });
    } else {
      console.warn('[DEBUG] Hytopia not available yet');
    }

    // Check document focus
    console.log('[DEBUG] Document focus:', {
      activeElement: document.activeElement?.tagName,
      activeElementId: document.activeElement?.id,
      hasFocus: document.hasFocus()
    });

    // Monitor focus changes
    window.addEventListener('focus', () => {
      console.log('[DEBUG] Window gained focus');
      // Ensure document can receive keyboard input
      if (document.activeElement && document.activeElement.tagName === 'BODY') {
        document.body.focus();
      }
    });
    window.addEventListener('blur', () => {
      console.log('[DEBUG] Window lost focus');
    });

    // Ensure body can receive focus for keyboard events
    document.body.setAttribute('tabindex', '-1');
    
    // Click on body to ensure focus
    document.addEventListener('click', (e) => {
      // If clicking on UI root (which has pointer-events: none), focus body
      if (e.target && e.target.closest && e.target.closest('.ui-root')) {
        // Don't interfere with UI clicks
        return;
      }
      // Focus body to ensure keyboard events work
      if (document.activeElement && document.activeElement.tagName !== 'INPUT' && document.activeElement.tagName !== 'TEXTAREA') {
        document.body.focus();
      }
    }, true);
  }

  function setupMobileButtons() {
    const mobileInteractButton = document.getElementById('mobile-interact-button');
    const mobileJumpButton = document.getElementById('mobile-jump-button');

    if (mobileInteractButton) {
      mobileInteractButton.addEventListener('touchstart', e => {
        e.preventDefault();
        mobileInteractButton.classList.add('active');
        hytopia.pressInput('ml', true);
      });

      mobileInteractButton.addEventListener('touchend', e => {
        e.preventDefault();
        mobileInteractButton.classList.remove('active');
        hytopia.pressInput('ml', false);
      });
    }

    if (mobileJumpButton) {
      mobileJumpButton.addEventListener('touchstart', e => {
        e.preventDefault();
        mobileJumpButton.classList.add('active');
        hytopia.pressInput(' ', true);
      });

      mobileJumpButton.addEventListener('touchend', e => {
        e.preventDefault();
        mobileJumpButton.classList.remove('active');
        hytopia.pressInput(' ', false);
      });
    }
  }

  /**
   * Roblox-style camera: mouse stays free; hold right click to look around.
   * Uses lockPointer(lock, maintainInput=true) so movement keys keep working
   * even when the pointer is unlocked for UI interaction.
   */
  function setupRightClickCamera() {
    let rightMouseHeld = false;

    const lockPointerSafe = (lock) => {
      if (typeof hytopia === 'undefined' || typeof hytopia.lockPointer !== 'function') return;
      try {
        hytopia.lockPointer(lock, true);
        console.log('[DEBUG] Pointer lock set to:', lock);
      } catch (err) {
        console.warn('[UI] lockPointer failed', err);
      }
    };

    // Try locking pointer initially - Hytopia may require this for keyboard input
    // The maintainInput=true parameter should allow movement even when locked
    console.log('[DEBUG] Attempting initial pointer lock for keyboard input');
    lockPointerSafe(true);
    
    // If that doesn't work, unlock after a short delay to allow UI interaction
    setTimeout(() => {
      console.log('[DEBUG] Unlocking pointer after initial lock attempt');
      lockPointerSafe(false);
    }, 100);

    // Prevent context menu so RMB can be used for camera look
    window.addEventListener('contextmenu', e => {
      e.preventDefault();
    });

    // Prevent mouse wheel from zooming the camera
    window.addEventListener('wheel', e => {
      // Only prevent zoom if not over a scrollable UI element
      const target = e.target;
      const isScrollable = target && (
        target.closest('.merchant-ui__content') ||
        target.closest('[style*="overflow"]') ||
        target.tagName === 'TEXTAREA' ||
        target.tagName === 'INPUT'
      );
      
      if (!isScrollable) {
        e.preventDefault();
        e.stopPropagation();
        e.stopImmediatePropagation();
        return false;
      }
    }, { passive: false, capture: true });

    window.addEventListener('mousedown', e => {
      if (e.button !== 2) return;
      e.preventDefault();
      rightMouseHeld = true;
      lockPointerSafe(true);
    });

    window.addEventListener('mouseup', e => {
      if (e.button !== 2) return;
      rightMouseHeld = false;
      lockPointerSafe(false);
    });

    // Safety: release pointer if focus is lost
    window.addEventListener('blur', () => {
      if (!rightMouseHeld) return;
      rightMouseHeld = false;
      lockPointerSafe(false);
    });
  }


  /**
   * Setup Merchant UI
   * Handles merchant selling interface
   */
  function setupMerchantUI() {
    const merchantUI = document.getElementById('merchant-ui');
    const merchantUIClose = document.getElementById('merchant-ui-close');
    const merchantUISellAll = document.getElementById('merchant-ui-sell-all');

    if (!merchantUI || !merchantUIClose || !merchantUISellAll) {
      console.warn('[UI] Merchant UI elements not found');
      return;
    }

    // Close button handler
    merchantUIClose.addEventListener('click', () => {
      console.log('[UI] Merchant UI close clicked');
      merchantUI.classList.remove('visible');
      hytopia.sendData({ type: 'CLOSE_MERCHANT_UI' });
    });

    // Sell All button handler
    merchantUISellAll.addEventListener('click', () => {
      console.log('[UI] Sell All clicked');
      hytopia.sendData({ type: 'SELL_ALL' });
    });
  }

  /**
   * Setup Mine Reset Upgrade UI
   * Handles mine reset upgrade interface
   */
  function setupMineResetUpgradeUI() {
    const upgradeUI = document.getElementById('mine-reset-upgrade-ui');
    const upgradeUIClose = document.getElementById('mine-reset-upgrade-ui-close');
    const upgradeButton = document.getElementById('mine-reset-upgrade-button');

    if (!upgradeUI || !upgradeUIClose || !upgradeButton) {
      console.warn('[UI] Mine Reset Upgrade UI elements not found');
      return;
    }

    // Close button handler
    upgradeUIClose.addEventListener('click', () => {
      console.log('[UI] Mine Reset Upgrade UI close clicked');
      upgradeUI.classList.remove('visible');
      hytopia.sendData({ type: 'CLOSE_MINE_RESET_UPGRADE_UI' });
    });

    // Purchase button handler - only process if not bought/disabled
    upgradeButton.addEventListener('click', (e) => {
      // Prevent click if button is disabled or bought
      if (upgradeButton.disabled || upgradeButton.classList.contains('bought')) {
        e.preventDefault();
        e.stopPropagation();
        return;
      }
      console.log('[UI] Mine Reset Upgrade button clicked');
      hytopia.sendData({ type: 'PURCHASE_MINE_RESET_UPGRADE' });
    });

    // Hover effect for button - only if not bought/disabled
    upgradeButton.addEventListener('mouseenter', () => {
      if (!upgradeButton.disabled && !upgradeButton.classList.contains('bought')) {
        console.log('[UI] Hovering over 2M button - button should increase in size');
        upgradeButton.style.transform = 'scale(1.05)';
      }
    });

    upgradeButton.addEventListener('mouseleave', () => {
      upgradeButton.style.transform = 'scale(1)';
    });
  }

  /**
   * Update Mine Reset Upgrade UI with player data
   */
  function updateMineResetUpgradeUI(hasUpgrade, cost, gold) {
    const upgradeUI = document.getElementById('mine-reset-upgrade-ui');
    const upgradeButton = document.getElementById('mine-reset-upgrade-button');
    const upgradeStatus = document.getElementById('mine-reset-upgrade-status');
    const buttonText = upgradeButton?.querySelector('.mine-reset-upgrade-ui__button-text');

    if (!upgradeUI || !upgradeButton || !upgradeStatus || !buttonText) return;

    const formatNumber = (value) => {
      if (value >= 1_000_000) {
        const num = value / 1_000_000;
        const formatted = num.toFixed(2);
        return (formatted.endsWith('.00') ? Math.round(num).toString() : formatted) + 'M';
      }
      if (value >= 1_000) {
        const num = value / 1_000;
        const formatted = num.toFixed(2);
        return (formatted.endsWith('.00') ? Math.round(num).toString() : formatted) + 'K';
      }
      return value.toLocaleString();
    };

    if (hasUpgrade) {
      buttonText.textContent = 'Bought!';
      upgradeButton.disabled = true;
      upgradeButton.classList.add('bought');
      upgradeButton.classList.add('disabled'); // Also add disabled class for styling
      upgradeButton.style.pointerEvents = 'none'; // Prevent any interaction
      upgradeButton.style.cursor = 'default';
      upgradeStatus.textContent = 'You have already purchased this upgrade!';
      upgradeStatus.className = 'mine-reset-upgrade-ui__status mine-reset-upgrade-ui__status--bought';
    } else {
      buttonText.textContent = formatNumber(cost);
      upgradeButton.disabled = false;
      upgradeButton.classList.remove('bought');
      upgradeButton.style.pointerEvents = 'auto'; // Re-enable interaction
      upgradeButton.style.cursor = 'pointer';
      const canAfford = gold >= cost;
      if (canAfford) {
        upgradeButton.classList.remove('disabled');
        upgradeStatus.textContent = `You have ${formatNumber(gold)} gold`;
        upgradeStatus.className = 'mine-reset-upgrade-ui__status mine-reset-upgrade-ui__status--can-afford';
      } else {
        upgradeButton.classList.add('disabled');
        upgradeStatus.textContent = `You need ${formatNumber(cost - gold)} more gold`;
        upgradeStatus.className = 'mine-reset-upgrade-ui__status mine-reset-upgrade-ui__status--cannot-afford';
      }
    }
  }

  /**
   * Setup Gem Trader UI
   * Handles gem trader upgrades interface
   */
  function setupGemTraderUI() {
    const gemTraderUI = document.getElementById('gem-trader-ui');
    const gemTraderUIClose = document.getElementById('gem-trader-ui-close');

    if (!gemTraderUI || !gemTraderUIClose) {
      console.warn('[UI] Gem Trader UI elements not found');
      return;
    }

    // Close button handler
    gemTraderUIClose.addEventListener('click', () => {
      console.log('[UI] Gem Trader UI close clicked');
      gemTraderUI.classList.remove('visible');
    });
  }

  /**
   * Update Gem Trader UI with upgrade data
   */
  function updateGemTraderUI(upgrades, gems) {
    const gemTraderUIContent = document.getElementById('gem-trader-ui-content');
    if (!gemTraderUIContent) return;

    // Clear existing items
    gemTraderUIContent.innerHTML = '';

    // Format number for display
    const formatNumber = (value) => {
      if (value >= 1_000_000_000_000) {
        const num = value / 1_000_000_000_000;
        const formatted = num.toFixed(2);
        return (formatted.endsWith('.00') ? Math.round(num).toString() : formatted) + 'T';
      }
      if (value >= 1_000_000_000) {
        const num = value / 1_000_000_000;
        const formatted = num.toFixed(2);
        return (formatted.endsWith('.00') ? Math.round(num).toString() : formatted) + 'B';
      }
      if (value >= 1_000_000) {
        const num = value / 1_000_000;
        const formatted = num.toFixed(2);
        return (formatted.endsWith('.00') ? Math.round(num).toString() : formatted) + 'M';
      }
      if (value >= 1_000) {
        const num = value / 1_000;
        const formatted = num.toFixed(2);
        return (formatted.endsWith('.00') ? Math.round(num).toString() : formatted) + 'K';
      }
      return value.toLocaleString();
    };

    // Upgrade definitions
    const upgradeDefs = [
      {
        key: 'moreGems',
        title: 'More Gems',
        icon: 'üíé',
        getEffect: (level) => {
          // UI shows level, backend is level + 1 (always 1 ahead)
          const displayLevel = level;
          const nextDisplayLevel = level + 1;
          return `${displayLevel}x -> ${nextDisplayLevel}x`;
        },
        getLevelProgress: (level) => {
          // TODO: Get max level from somewhere when defined
          const maxLevel = 50;
          return `${level}/${maxLevel}`;
        },
      },
      {
        key: 'moreRebirths',
        title: 'More Rebirths',
        icon: 'üîÑ',
        getEffect: (level) => {
          return `${level} -> ${level + 1}`;
        },
        getLevelProgress: (level) => {
          const maxLevel = 35;
          return `${level}/${maxLevel}`;
        },
      },
      {
        key: 'moreCoins',
        title: 'More Coins',
        icon: 'üí∞',
        getEffect: (level) => {
          // Display shows bonus percentage: level 0 = 0%, level 1 = 10%, etc.
          // Backend multiplier is 1.0 + (level * 0.1), so level 1 = 1.1x (110% total)
          const currentPercent = level * 10;
          const nextPercent = (level + 1) * 10;
          return `${currentPercent}% -> ${nextPercent}%`;
        },
        getLevelProgress: (level) => {
          const maxLevel = 160; // 0-159 = 160 total levels
          return `${level}/${maxLevel}`;
        },
      },
      {
        key: 'moreDamage',
        title: 'More Damage',
        icon: '‚õèÔ∏è',
        getEffect: (level) => {
          // Display shows bonus percentage: level 0 = 0%, level 1 = 10%, etc.
          // Backend multiplier is 1.0 + (level * 0.1), so level 1 = 1.1x (110% total)
          const currentPercent = level * 10;
          const nextPercent = (level + 1) * 10;
          return `${currentPercent}% -> ${nextPercent}%`;
        },
        getLevelProgress: (level) => {
          const maxLevel = 50; // 0-49 = 50 total levels
          return `${level}/${maxLevel}`;
        },
      },
    ];

    for (const upgradeDef of upgradeDefs) {
      const upgradeData = upgrades[upgradeDef.key];
      if (!upgradeData) continue;

      const level = upgradeData.level || 0;
      const cost = upgradeData.cost || 0;
      const canAfford = upgradeData.canAfford || false;

      // Create upgrade item container
      const item = document.createElement('div');
      item.className = 'gem-trader-ui__upgrade-item';

      // Icon with arrow overlay
      const iconContainer = document.createElement('div');
      iconContainer.className = 'gem-trader-ui__icon-container';
      const icon = document.createElement('div');
      icon.className = 'gem-trader-ui__icon';
      icon.textContent = upgradeDef.icon;
      const arrowOverlay = document.createElement('div');
      arrowOverlay.className = 'gem-trader-ui__arrow-overlay';
      arrowOverlay.textContent = '‚Üë';
      iconContainer.appendChild(icon);
      iconContainer.appendChild(arrowOverlay);
      item.appendChild(iconContainer);

      // Upgrade details (title, effect, level, cost)
      const details = document.createElement('div');
      details.className = 'gem-trader-ui__details';

      // Title
      const title = document.createElement('div');
      title.className = 'gem-trader-ui__upgrade-title';
      title.textContent = upgradeDef.title;
      details.appendChild(title);

      // Effect (current -> next)
      const effect = document.createElement('div');
      effect.className = 'gem-trader-ui__effect';
      effect.textContent = upgradeDef.getEffect(level);
      details.appendChild(effect);

      // Level progress and cost container
      const levelCostContainer = document.createElement('div');
      levelCostContainer.className = 'gem-trader-ui__level-cost-container';

      // Level progress
      const levelProgress = document.createElement('div');
      levelProgress.className = 'gem-trader-ui__level-progress';
      const levelArrow = document.createElement('span');
      levelArrow.className = 'gem-trader-ui__level-arrow';
      levelArrow.textContent = '‚Üë';
      levelProgress.appendChild(levelArrow);
      const levelText = document.createElement('span');
      levelText.textContent = upgradeDef.getLevelProgress(level);
      levelProgress.appendChild(levelText);
      levelCostContainer.appendChild(levelProgress);

      // Cost
      const costContainer = document.createElement('div');
      costContainer.className = 'gem-trader-ui__cost';
      const gemIcon = document.createElement('span');
      gemIcon.className = 'gem-trader-ui__gem-icon';
      gemIcon.textContent = 'üíé';
      costContainer.appendChild(gemIcon);
      const costText = document.createElement('span');
      costText.textContent = formatNumber(cost);
      costContainer.appendChild(costText);
      levelCostContainer.appendChild(costContainer);

      details.appendChild(levelCostContainer);
      item.appendChild(details);

      // Upgrade button
      const upgradeButton = document.createElement('button');
      upgradeButton.className = `gem-trader-ui__upgrade-button ${canAfford ? 'can-afford' : 'cannot-afford'}`;
      upgradeButton.textContent = '+';
      upgradeButton.disabled = !canAfford;
      upgradeButton.addEventListener('click', () => {
        console.log(`[UI] Upgrade ${upgradeDef.key} clicked`);
        hytopia.sendData({ type: 'PURCHASE_UPGRADE', upgradeType: upgradeDef.key });
      });
      item.appendChild(upgradeButton);

      gemTraderUIContent.appendChild(item);
    }
  }

  /**
   * Update Merchant UI with inventory data
   */
  function updateMerchantUI(inventory, totalValue, gold, oreSellValues) {
    const merchantUIContent = document.getElementById('merchant-ui-content');
    if (!merchantUIContent) return;

    // Clear existing items
    merchantUIContent.innerHTML = '';

    // Get ore data for values (matching NEW ORE_DATABASE from OreData.ts - 24 ores)
    const oreData = {
      'stone': { name: 'Stone', value: 2, color: 'stone' },
      'deepslate': { name: 'Deepslate', value: 5, color: 'stone' },
      'coal': { name: 'Coal', value: 6, color: 'coal' },
      'iron': { name: 'Iron', value: 10, color: 'iron' },
      'tin': { name: 'Tin', value: 15, color: 'iron' },
      'cobalt': { name: 'Cobalt', value: 50, color: 'cobalt' },
      'pyrite': { name: 'Pyrite', value: 100, color: 'gold' },
      'gold': { name: 'Gold', value: 250, color: 'gold' },
      'obsidian': { name: 'Obsidian', value: 500, color: 'obsidian' },
      'ruby': { name: 'Ruby', value: 1000, color: 'ruby' },
      'diamond': { name: 'Diamond', value: 2000, color: 'diamond' },
      'amber': { name: 'Amber', value: 3500, color: 'amber' },
      'quartz': { name: 'Quartz', value: 5000, color: 'quartz' },
      'topaz': { name: 'Topaz', value: 10000, color: 'topaz' },
      'emerald': { name: 'Emerald', value: 20000, color: 'emerald' },
      'relic': { name: 'Relic', value: 50000, color: 'relic' },
      'amethyst': { name: 'Amethyst', value: 75000, color: 'amethyst' },
      'sapphire': { name: 'Sapphire', value: 150000, color: 'sapphire' },
      'luminite': { name: 'Luminite', value: 250000, color: 'luminite' },
      'prismatic': { name: 'Prismatic', value: 350000, color: 'prismatic' },
      'sunstone': { name: 'Sunstone', value: 450000, color: 'sunstone' },
      'mithrial': { name: 'Mithrial', value: 600000, color: 'mithrial' },
      'astralite': { name: 'Astralite', value: 800000, color: 'astralite' },
      'dragonstone': { name: 'Dragonstone', value: 1500000, color: 'dragonstone' },
    };

    // Format number for display (2 decimals for money/power, but hide .00)
    const formatNumber = (value) => {
      if (value >= 1_000_000_000_000_000_000) {
        const num = value / 1_000_000_000_000_000_000;
        const formatted = num.toFixed(2);
        return (formatted.endsWith('.00') ? Math.round(num).toString() : formatted) + 'S'; // Sextillion
      }
      if (value >= 1_000_000_000_000_000) {
        const num = value / 1_000_000_000_000_000;
        const formatted = num.toFixed(2);
        return (formatted.endsWith('.00') ? Math.round(num).toString() : formatted) + 'Q'; // Quadrillion
      }
      if (value >= 1_000_000_000_000) {
        const num = value / 1_000_000_000_000;
        const formatted = num.toFixed(2);
        return (formatted.endsWith('.00') ? Math.round(num).toString() : formatted) + 'T'; // Trillion
      }
      if (value >= 1_000_000_000) {
        const num = value / 1_000_000_000;
        const formatted = num.toFixed(2);
        return (formatted.endsWith('.00') ? Math.round(num).toString() : formatted) + 'B'; // Billion
      }
      if (value >= 1_000_000) {
        const num = value / 1_000_000;
        const formatted = num.toFixed(2);
        return (formatted.endsWith('.00') ? Math.round(num).toString() : formatted) + 'M'; // Million
      }
      if (value >= 1_000) {
        const num = value / 1_000;
        const formatted = num.toFixed(2);
        return (formatted.endsWith('.00') ? Math.round(num).toString() : formatted) + 'K'; // Thousand
      }
      const formatted = value.toFixed(2);
      return formatted.endsWith('.00') ? Math.round(value).toString() : formatted;
    };

    // Create ore items
    const oreTypes = Object.keys(inventory).filter(oreType => inventory[oreType] > 0);
    
    if (oreTypes.length === 0) {
      const emptyMessage = document.createElement('div');
      emptyMessage.style.padding = '20px';
      emptyMessage.style.textAlign = 'center';
      emptyMessage.style.color = '#aaa';
      emptyMessage.textContent = 'No ores in inventory';
      merchantUIContent.appendChild(emptyMessage);
      return;
    }

    // Sort ores by value (highest first)
    oreTypes.sort((a, b) => {
      const valueA = oreData[a]?.value || 0;
      const valueB = oreData[b]?.value || 0;
      return valueB - valueA;
    });

    for (const oreType of oreTypes) {
      const amount = inventory[oreType];
      const data = oreData[oreType];
      
      if (!data || amount <= 0) continue;

      const item = document.createElement('div');
      item.className = 'merchant-ui__ore-item';

      // Ore info (left side)
      const oreInfo = document.createElement('div');
      oreInfo.className = 'merchant-ui__ore-info';

      const oreName = document.createElement('div');
      oreName.className = `merchant-ui__ore-name ${data.color}`;
      oreName.textContent = `${data.name} (x${amount})`;
      oreInfo.appendChild(oreName);

      item.appendChild(oreInfo);

      // Value (middle)
      const oreValue = document.createElement('div');
      oreValue.className = 'merchant-ui__ore-value';
      const coinIcon = document.createElement('span');
      coinIcon.className = 'merchant-ui__coin-icon';
      oreValue.appendChild(coinIcon);
      const valueText = document.createElement('span');
      // Use oreSellValues if provided (includes all multipliers), otherwise use base value
      const sellPrice = oreSellValues && oreSellValues[oreType] !== undefined 
        ? oreSellValues[oreType] 
        : data.value;
      valueText.textContent = formatNumber(sellPrice);
      oreValue.appendChild(valueText);
      item.appendChild(oreValue);

      // Sell button (right side)
      const sellButton = document.createElement('button');
      sellButton.className = 'merchant-ui__sell-button';
      sellButton.textContent = 'Sell';
      sellButton.addEventListener('click', () => {
        console.log(`[UI] Sell ${oreType} clicked`);
        hytopia.sendData({ type: 'SELL_ORE', oreType });
      });
      item.appendChild(sellButton);

      merchantUIContent.appendChild(item);
    }
  }

  function setupPowerHud() {
    const powerValueEl = document.getElementById('power-value');
    const moneyValueEl = document.getElementById('money-value');
    const gemsValueEl = document.getElementById('gems-value');
    const winsValueEl = document.getElementById('wins-value');
    const rebirthsValueEl = document.getElementById('rebirths-value');
    const powerGainLayer = document.getElementById('power-gain-layer');
    const trainingPromptEl = document.getElementById('training-prompt');
    const trainingPromptTitleEl = document.getElementById('training-prompt-title');
    const trainingPromptSubtitleEl = document.getElementById('training-prompt-subtitle');
    const trainingPromptKeyEl = document.getElementById('training-prompt-key');

    // Mining UI elements
    const miningHudEl = document.getElementById('mining-hud');
    const damageDisplayEl = document.getElementById('damage-display');
    const minedOreLayerEl = document.getElementById('mined-ore-layer');
    const damagePopupLayerEl = document.getElementById('damage-popup-layer');
    const blockHealthBarEl = document.getElementById('block-health-bar');
    const blockHealthBarNameEl = document.getElementById('block-health-bar-name');
    const blockHealthBarFillEl = document.getElementById('block-health-bar-fill');
    const blockHealthBarTextEl = document.getElementById('block-health-bar-text');
    const blockRewardDisplayEl = document.getElementById('block-reward-display');
    const mineResetTimerEl = document.getElementById('mine-reset-timer');
    const mineResetTimerTextEl = document.getElementById('mine-reset-timer-text');
    const miningDepthCounterEl = document.getElementById('mining-depth-counter');
    const miningDepthCounterTextEl = document.getElementById('mining-depth-counter-text');

    console.log('[UI] Setting up power HUD');
    console.log('[UI] powerValueEl:', powerValueEl);
    console.log('[UI] powerGainLayer:', powerGainLayer);

    const minerButton = document.getElementById('miner-button');
    const pickaxeButton = document.getElementById('pickaxe-button');
    const rebirthButton = document.getElementById('rebirth-button');
    const petsButton = document.getElementById('pets-button');
    const minerModal = document.getElementById('miner-modal');
    const pickaxeModal = document.getElementById('pickaxe-modal');
    const rebirthModal = document.getElementById('rebirth-modal');
    const petsModal = document.getElementById('pets-modal');
    const eggModal = document.getElementById('egg-modal');
    const minerGridEl = document.getElementById('miner-grid');
    const minerDetailName = document.getElementById('miner-detail-name');
    const minerDetailStats = document.getElementById('miner-detail-stats');
    const minerDetailBadge = document.getElementById('miner-detail-badge');
    const minerDetailIcon = document.getElementById('miner-detail-icon');
    const pickaxeGridEl = document.getElementById('pickaxe-grid');
    const pickaxeDetailName = document.getElementById('pickaxe-detail-name');
    const pickaxeDetailStats = document.getElementById('pickaxe-detail-stats');
    const pickaxeDetailCost = document.getElementById('pickaxe-detail-cost');

    // Pets UI elements (grid)
    const petsGridEl = document.getElementById('pets-grid');
    const petsOwnedCountEl = document.getElementById('pets-owned-count');
    const petsEquippedCountEl = document.getElementById('pets-equipped-count');
    const petsMultiplierSumEl = document.getElementById('pets-multiplier-sum');
    const petsEquipBestBtn = document.getElementById('pets-equip-best');
    const petsUnequipAllBtn = document.getElementById('pets-unequip-all');
    const petsTrashToggleBtn = document.getElementById('pets-trash-toggle');
    const petsDeleteBarEl = document.getElementById('pets-delete-bar');
    const petsDeleteTextEl = document.getElementById('pets-delete-text');
    const petsDeleteConfirmBtn = document.getElementById('pets-delete-confirm');
    const petsDeleteCancelBtn = document.getElementById('pets-delete-cancel');
    const petDetailPanelEl = document.getElementById('pet-detail-panel');
    const petDetailCloseEl = document.getElementById('pet-detail-close');
    const petDetailNameEl = document.getElementById('pet-detail-name');
    const petDetailImageEl = document.getElementById('pet-detail-image');
    const petDetailMultEl = document.getElementById('pet-detail-mult');
    const petDetailRarityEl = document.getElementById('pet-detail-rarity');
    const petDetailActionEl = document.getElementById('pet-detail-action');

    // Egg station UI elements
    const eggModalTitleEl = document.getElementById('egg-modal-title');
    const eggStationNameEl = document.getElementById('egg-station-name');
    const eggStationCostEl = document.getElementById('egg-station-cost');
    const eggStationGoldEl = document.getElementById('egg-station-gold');
    const eggStationInvEl = document.getElementById('egg-station-inv');
    const eggStationStatusEl = document.getElementById('egg-station-status');
    const eggOpen1Btn = document.getElementById('egg-open-1');
    const eggOpen3Btn = document.getElementById('egg-open-3');
    const eggAutoBtn = document.getElementById('egg-auto');
    const eggResultsListEl = document.getElementById('egg-results-list');

    // Setup miner button click handler
    if (minerButton) {
      minerButton.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        hytopia.sendData({ type: 'MODAL_OPENED', modalType: 'miner' });
        hytopia.sendData({ type: 'OPEN_MINER_SHOP' });
      });
    }

    // Setup pickaxe button click handler
    if (pickaxeButton) {
      pickaxeButton.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        console.log('[UI] Pickaxe button clicked');
        // Immediately notify server that modal is opening (before sending shop data request)
        // This prevents any click events from triggering mining
        hytopia.sendData({ type: 'MODAL_OPENED', modalType: 'pickaxe' });
        hytopia.sendData({ type: 'OPEN_PICKAXE_SHOP' });
      });
    }

    // Setup rebirth button click handler
    if (rebirthButton) {
      rebirthButton.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        console.log('[UI] Rebirth button clicked');
        // Immediately notify server that modal is opening (before sending rebirth data request)
        // This prevents any click events from triggering mining
        hytopia.sendData({ type: 'MODAL_OPENED', modalType: 'rebirth' });
        hytopia.sendData({ type: 'OPEN_REBIRTH_UI' });
      });
    }

    // Setup pets button click handler (HUD below rebirth)
    if (petsButton) {
      petsButton.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        // Always start with delete mode OFF when opening the pets UI.
        // This ensures the delete bar stays hidden until the trashcan is clicked.
        state.pets.deleteMode = false;
        state.pets.deleteSelected = {};
        state.pets.selectedPetInstanceId = null;
        if (petsDeleteBarEl) petsDeleteBarEl.hidden = true;
        if (petDetailPanelEl) petDetailPanelEl.hidden = true;

        hytopia.sendData({ type: 'MODAL_OPENED', modalType: 'pets' });
        hytopia.sendData({ type: 'REQUEST_PET_STATE' });
        showModal(petsModal);
        petsButton.blur();
        window.focus();
      });
    }

    // Setup modal close handlers
    document.addEventListener('click', (e) => {
      // Use closest to find the close button (handles clicks on text/children inside button)
      const closeButton = e.target.closest('.pickaxe-modal__close, .modal__close, .rebirth-modal__close');
      
      if (closeButton) {
        const modalId = closeButton.getAttribute('data-close');
        if (modalId) {
          const modal = document.getElementById(modalId);
          if (modal) {
            e.preventDefault();
            e.stopPropagation();
            hideModal(modal); // Use hideModal to notify server
            console.log(`[UI] Closed modal: ${modalId}`);
          }
        }
      }
    });
    const rebirthOptionsEl = document.getElementById('rebirth-options');
    const rebirthBadge = document.getElementById('rebirth-badge');

    const state = {
      power: 0,
      gold: 0,
      gems: 0,
      wins: 0,
      rebirths: 0,
      miner: {
        currentTier: -1,
        selectedTier: -1,
        miners: [],
      },
      pickaxe: {
        currentTier: 0,
        selectedTier: undefined,
        pickaxes: [],
      },
      rebirth: {
        options: [],
        power: 0,
        rebirths: 0,
        maxRebirths: 0,
      },
      prompt: {
        visible: false,
        rockName: 'Training Rock',
        requirements: { power: 0, rebirths: 0 },
        canTrain: false,
        powerPerHit: 0,
        actionKey: 'E',
      },
      mining: {
        isMining: false,
        currentOre: null,
        damage: 0,
        lastBlockInfo: null, // Store last known block info to prevent UI disappearing during fast mining
      },
      pets: {
        pets: [],
        ownedCount: 0,
        ownedCap: 50,
        equippedCount: 0,
        equippedCap: 8,
        multiplierSum: 0,
        trainingMultiplier: 1,
        selectedPetInstanceId: null,
        deleteMode: false,
        deleteSelected: {}, // map instanceId -> true (inventory only)
      },
      eggStation: {
        inProximity: false,
        stationId: null,
        stationName: 'Egg Station',
        eggType: 'stone',
        defaultOpenCount: 1,
        costGold: 0,
        lastHatch: [],
        autoEnabled: false,
      },
    };

    const formatNumber = value => {
      // Format: Max 3 digits before decimal, max 2 after, then letter suffix
      // Abbreviations: T, Qd, Qn, Sx, Sp, c, Oc, No, De, UDe
      
      // Helper to format and remove trailing zeros
      const formatValue = (num, suffix) => {
        const formatted = num.toFixed(2);
        const cleaned = formatted.endsWith('.00') ? Math.round(num).toString() : formatted.replace(/\.?0+$/, '');
        return cleaned + suffix;
      };
      
      if (value >= 1e36) {
        // Undecillion (1e36)
        const num = value / 1e36;
        if (num >= 1000) {
          return formatValue(num / 1000, 'UDe');
        }
        return formatValue(num, 'UDe');
      }
      if (value >= 1e33) {
        // Decillion (1e33)
        const num = value / 1e33;
        if (num >= 1000) {
          return formatValue(num / 1000, 'UDe');
        }
        return formatValue(num, 'De');
      }
      if (value >= 1e30) {
        // Nonillion (1e30)
        const num = value / 1e30;
        if (num >= 1000) {
          return formatValue(num / 1000, 'De');
        }
        return formatValue(num, 'No');
      }
      if (value >= 1e27) {
        // Octillion (1e27)
        const num = value / 1e27;
        if (num >= 1000) {
          return formatValue(num / 1000, 'No');
        }
        return formatValue(num, 'Oc');
      }
      if (value >= 1e26) {
        // Custom 'c' tier (1e26, between Sp and Oc)
        const num = value / 1e26;
        if (num >= 1000) {
          return formatValue(num / 1000, 'Oc');
        }
        return formatValue(num, 'c');
      }
      if (value >= 1e24) {
        // Septillion (1e24)
        const num = value / 1e24;
        if (num >= 1000) {
          return formatValue(num / 1000, 'c');
        }
        return formatValue(num, 'Sp');
      }
      if (value >= 1e21) {
        // Sextillion (1e21)
        const num = value / 1e21;
        if (num >= 1000) {
          return formatValue(num / 1000, 'Sp');
        }
        return formatValue(num, 'Sx');
      }
      if (value >= 1e18) {
        // Quintillion (1e18)
        const num = value / 1e18;
        if (num >= 1000) {
          return formatValue(num / 1000, 'Sx');
        }
        return formatValue(num, 'Qn');
      }
      if (value >= 1e15) {
        // Quadrillion (1e15)
        const num = value / 1e15;
        if (num >= 1000) {
          return formatValue(num / 1000, 'Qn');
        }
        return formatValue(num, 'Qd');
      }
      if (value >= 1e12) {
        // Trillion (1e12)
        const num = value / 1e12;
        if (num >= 1000) {
          return formatValue(num / 1000, 'Qd');
        }
        return formatValue(num, 'T');
      }
      if (value >= 1_000_000_000) {
        // Billion
        const num = value / 1_000_000_000;
        if (num >= 1000) {
          return formatValue(num / 1000, 'T');
        }
        return formatValue(num, 'B');
      }
      if (value >= 1_000_000) {
        // Million
        const num = value / 1_000_000;
        if (num >= 1000) {
          return formatValue(num / 1000, 'B');
        }
        return formatValue(num, 'M');
      }
      if (value >= 1_000) {
        // Thousand
        const num = value / 1_000;
        if (num >= 1000) {
          return formatValue(num / 1000, 'M');
        }
        return formatValue(num, 'K');
      }
      // Less than 1000 - show as integer
      return Math.round(value).toString();
    };

    // Egg station local auto-open loop (client-side)
    let eggAutoInterval = null;
    const stopEggAuto = () => {
      state.eggStation.autoEnabled = false;
      if (eggAutoInterval) {
        clearInterval(eggAutoInterval);
        eggAutoInterval = null;
      }
      if (eggAutoBtn) {
        eggAutoBtn.textContent = 'Auto';
      }
    };

    const startEggAuto = () => {
      stopEggAuto();
      state.eggStation.autoEnabled = true;
      if (eggAutoBtn) {
        eggAutoBtn.textContent = 'Stop';
      }
      // Send first hatch immediately, then every ~600ms (server-side rate limits still apply)
      const doHatch = () => {
        if (!state.eggStation.inProximity) {
          stopEggAuto();
          return;
        }
        const count = state.eggStation.defaultOpenCount === 3 ? 3 : 1;
        hytopia.sendData({ type: 'EGG_HATCH', eggType: state.eggStation.eggType, count });
      };
      doHatch();
      eggAutoInterval = setInterval(doHatch, 600);
    };

    const renderEggStation = () => {
      if (!eggModal) return;
      if (!state.eggStation.inProximity) return;

      if (eggModalTitleEl) eggModalTitleEl.textContent = 'Egg Station';
      if (eggStationNameEl) eggStationNameEl.textContent = state.eggStation.stationName || 'Egg Station';
      if (eggStationCostEl) eggStationCostEl.textContent = formatNumber(state.eggStation.costGold || 0);
      if (eggStationGoldEl) eggStationGoldEl.textContent = formatNumber(state.gold || 0);
      if (eggStationInvEl) eggStationInvEl.textContent = `${state.pets.ownedCount}/${state.pets.ownedCap}`;
      if (eggStationStatusEl) {
        eggStationStatusEl.textContent = state.eggStation.autoEnabled ? 'Auto Opening...' : 'Ready';
      }

      if (eggOpen1Btn) {
        const c = state.eggStation.costGold || 0;
        eggOpen1Btn.textContent = `Open 1 (${formatNumber(c)})`;
      }
      if (eggOpen3Btn) {
        const c = (state.eggStation.costGold || 0) * 3;
        eggOpen3Btn.textContent = `Open 3 (${formatNumber(c)})`;
      }

      if (eggResultsListEl) {
        eggResultsListEl.innerHTML = '';
        const last = Array.isArray(state.eggStation.lastHatch) ? state.eggStation.lastHatch : [];
        if (last.length === 0) {
          const empty = document.createElement('div');
          empty.style.opacity = '0.8';
          empty.textContent = 'No hatches yet.';
          eggResultsListEl.appendChild(empty);
        } else {
          for (const pet of last.slice(0, 12)) {
            const row = document.createElement('div');
            row.className = 'egg-result-item';
            const left = document.createElement('div');
            left.className = 'egg-result-item__name';
            left.textContent = pet.name || pet.id || 'Pet';
            const right = document.createElement('div');
            right.className = 'egg-result-item__mult';
            right.textContent = `+${pet.multiplier ?? 0}`;
            row.appendChild(left);
            row.appendChild(right);
            eggResultsListEl.appendChild(row);
          }
        }
      }
    };

    const renderPets = () => {
      // Top counters
      if (petsOwnedCountEl) petsOwnedCountEl.textContent = `${state.pets.ownedCount}/${state.pets.ownedCap}`;
      if (petsEquippedCountEl) petsEquippedCountEl.textContent = `${state.pets.equippedCount}/${state.pets.equippedCap}`;
      if (petsMultiplierSumEl) petsMultiplierSumEl.textContent = String(state.pets.multiplierSum ?? 0);

      // Delete bar
      if (petsDeleteBarEl) {
        const selectedCount = state.pets.deleteSelected ? Object.keys(state.pets.deleteSelected).length : 0;
        // Show whenever delete mode is enabled (even at 0 selected), like the reference UX.
        petsDeleteBarEl.hidden = !state.pets.deleteMode;
        if (petsDeleteTextEl) petsDeleteTextEl.textContent = `Delete ${selectedCount} Pets!`;
        if (petsDeleteConfirmBtn) petsDeleteConfirmBtn.disabled = selectedCount === 0;
      }

      // Disable bulk actions during delete mode
      if (petsEquipBestBtn) petsEquipBestBtn.disabled = Boolean(state.pets.deleteMode);
      if (petsUnequipAllBtn) petsUnequipAllBtn.disabled = Boolean(state.pets.deleteMode);

      if (!petsGridEl) return;
      petsGridEl.innerHTML = '';

      const rarityToClass = (rarity) => {
        switch ((rarity || '').toLowerCase()) {
          case 'legendary': return 'pet-tile--legendary';
          case 'epic': return 'pet-tile--epic';
          case 'rare': return 'pet-tile--rare';
          default: return 'pet-tile--common';
        }
      };

      const list = Array.isArray(state.pets.pets) ? state.pets.pets : [];
      // Sort like typical pet inventories: equipped first, then highest multiplier.
      list.sort((a, b) => {
        const ea = Boolean(a.equipped);
        const eb = Boolean(b.equipped);
        if (ea !== eb) return ea ? -1 : 1;
        return (b.multiplier ?? 0) - (a.multiplier ?? 0);
      });

      const getSelectedPet = () => {
        if (!state.pets.selectedPetInstanceId) return null;
        return list.find(p => p.instanceId === state.pets.selectedPetInstanceId) || null;
      };

      const renderPetDetail = (pet) => {
        if (!petDetailPanelEl) return;
        if (!pet) {
          petDetailPanelEl.hidden = true;
          return;
        }
        petDetailPanelEl.hidden = false;

        if (petDetailNameEl) petDetailNameEl.textContent = pet.name || pet.id || 'Pet';
        if (petDetailMultEl) petDetailMultEl.textContent = String(pet.multiplier ?? 0);
        if (petDetailRarityEl) petDetailRarityEl.textContent = (pet.rarity || '').toUpperCase();

        if (petDetailImageEl) {
          petDetailImageEl.innerHTML = '';
          const img = document.createElement('img');
          img.alt = pet.name || pet.petId || 'Pet';
          img.src = `{{CDN_ASSETS_URL}}/ui/pets/${pet.petId}.png`;
          img.className = 'pet-detail__img-el';
          img.onerror = () => {
            petDetailImageEl.textContent = 'üêæ';
          };
          petDetailImageEl.appendChild(img);
        }

        if (petDetailActionEl) {
          const isEquipped = Boolean(pet.equipped);
          petDetailActionEl.textContent = isEquipped ? 'Unequip' : 'Equip';
          petDetailActionEl.classList.toggle('pet-detail__action--equip', !isEquipped);
          petDetailActionEl.classList.toggle('pet-detail__action--unequip', isEquipped);
        }
      };

      // Keep detail panel synced with latest state
      renderPetDetail(getSelectedPet());

      for (const pet of list) {
        const tile = document.createElement('button');
        const isMarkedForDelete = Boolean(state.pets.deleteSelected?.[pet.instanceId]);
        tile.className = `pet-tile ${rarityToClass(pet.rarity)} ${pet.equipped ? 'pet-tile--equipped' : ''} ${state.pets.deleteMode ? 'pet-tile--delete-mode' : ''} ${isMarkedForDelete ? 'pet-tile--delete-selected' : ''}`;
        tile.setAttribute('tabindex', '-1');

        const imgWrap = document.createElement('div');
        imgWrap.className = 'pet-tile__img';

        // If you later add images at assets/ui/pets/<petId>.png this will pick them up automatically.
        const img = document.createElement('img');
        img.className = 'pet-tile__img-el';
        img.alt = pet.name || pet.petId || 'Pet';
        img.src = `{{CDN_ASSETS_URL}}/ui/pets/${pet.petId}.png`;
        img.onerror = () => {
          img.style.display = 'none';
          imgWrap.textContent = 'üêæ';
        };
        imgWrap.appendChild(img);

        const mult = document.createElement('div');
        mult.className = 'pet-tile__mult';
        mult.textContent = String(pet.multiplier ?? 0);

        tile.appendChild(imgWrap);
        tile.appendChild(mult);

        if (state.pets.deleteMode) {
          const overlay = document.createElement('div');
          overlay.className = 'pet-tile__delete-overlay';
          overlay.textContent = '‚úñ';
          overlay.style.display = isMarkedForDelete ? 'flex' : 'none';
          tile.appendChild(overlay);
        }

        tile.addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation();
          if (state.pets.deleteMode) {
            // Only allow marking inventory pets (inv:<idx>) and never equipped
            const isInventory = typeof pet.instanceId === 'string' && pet.instanceId.startsWith('inv:');
            if (!isInventory || pet.equipped) return;

            if (!state.pets.deleteSelected) state.pets.deleteSelected = {};
            if (state.pets.deleteSelected[pet.instanceId]) {
              delete state.pets.deleteSelected[pet.instanceId];
            } else {
              state.pets.deleteSelected[pet.instanceId] = true;
            }
            // Close detail panel while in delete mode
            state.pets.selectedPetInstanceId = null;
            if (petDetailPanelEl) petDetailPanelEl.hidden = true;
            // Re-render to update overlays
            renderPets();
            return;
          }

          state.pets.selectedPetInstanceId = pet.instanceId;
          renderPetDetail(pet);
        });

        petsGridEl.appendChild(tile);
      }
    };

    // Footer buttons
    if (petsEquipBestBtn) {
      petsEquipBestBtn.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        hytopia.sendData({ type: 'PET_EQUIP_BEST' });
      });
    }
    if (petsUnequipAllBtn) {
      petsUnequipAllBtn.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        hytopia.sendData({ type: 'PET_UNEQUIP_ALL' });
      });
    }

    if (petsTrashToggleBtn) {
      petsTrashToggleBtn.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        state.pets.deleteMode = !state.pets.deleteMode;
        // Reset selection when leaving delete mode
        if (!state.pets.deleteMode) {
          state.pets.deleteSelected = {};
        }
        // Hide detail panel while in delete mode
        if (state.pets.deleteMode) {
          state.pets.selectedPetInstanceId = null;
          if (petDetailPanelEl) petDetailPanelEl.hidden = true;
        }
        renderPets();
      });
    }

    if (petsDeleteCancelBtn) {
      petsDeleteCancelBtn.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        state.pets.deleteSelected = {};
        state.pets.deleteMode = false;
        if (petsDeleteBarEl) petsDeleteBarEl.hidden = true;
        renderPets();
      });
    }

    if (petsDeleteConfirmBtn) {
      petsDeleteConfirmBtn.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        const selected = state.pets.deleteSelected || {};
        const instanceIds = Object.keys(selected);
        const indices = instanceIds
          .filter((id) => id.startsWith('inv:'))
          .map((id) => Number(id.split(':')[1]))
          .filter((n) => Number.isFinite(n));
        if (indices.length === 0) return;
        hytopia.sendData({ type: 'PET_DELETE_INV', indices });
        // Optimistically exit delete mode; server PET_STATE will refresh the grid
        state.pets.deleteSelected = {};
        state.pets.deleteMode = false;
        if (petsDeleteBarEl) petsDeleteBarEl.hidden = true;
      });
    }

    // Pet detail panel controls
    if (petDetailCloseEl) {
      petDetailCloseEl.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        state.pets.selectedPetInstanceId = null;
        if (petDetailPanelEl) petDetailPanelEl.hidden = true;
      });
    }
    if (petDetailActionEl) {
      petDetailActionEl.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        const list = Array.isArray(state.pets.pets) ? state.pets.pets : [];
        const current = state.pets.selectedPetInstanceId ? (list.find(p => p.instanceId === state.pets.selectedPetInstanceId) || null) : null;
        if (!current) return;
        if (current.equipped) {
          hytopia.sendData({ type: 'PET_UNEQUIP_INSTANCE', slotIndex: current.slotIndex });
        } else {
          hytopia.sendData({ type: 'PET_EQUIP_INSTANCE', slotIndex: current.slotIndex });
        }
      });
    }

    // Wire egg station buttons once
    if (eggOpen1Btn) {
      eggOpen1Btn.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        hytopia.sendData({ type: 'EGG_HATCH', eggType: state.eggStation.eggType, count: 1 });
      });
    }
    if (eggOpen3Btn) {
      eggOpen3Btn.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        hytopia.sendData({ type: 'EGG_HATCH', eggType: state.eggStation.eggType, count: 3 });
      });
    }
    if (eggAutoBtn) {
      eggAutoBtn.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        if (state.eggStation.autoEnabled) {
          stopEggAuto();
        } else {
          startEggAuto();
        }
        renderEggStation();
      });
    }

    // Store background click handlers and container click handlers for cleanup
    const modalBackgroundHandlers = new Map();
    const modalContainerHandlers = new Map();

    const showModal = (el) => {
      if (!el) return;
      el.classList.add('visible');
      
      // Create and store background click handler
      const handleBackgroundClick = (e) => {
        // Only close if clicking directly on the modal background (not on the container)
        if (e.target === el) {
          hideModal(el);
        }
      };
      
      // Remove any existing listener first
      const existingHandler = modalBackgroundHandlers.get(el);
      if (existingHandler) {
        el.removeEventListener('click', existingHandler);
      }
      
      // Add new handler and store it
      el.addEventListener('click', handleBackgroundClick);
      modalBackgroundHandlers.set(el, handleBackgroundClick);
      
      // Prevent clicks inside the modal container from closing
      // But allow close button clicks to work
      const container = el.querySelector('.pickaxe-modal__container');
      if (container) {
        // Remove existing container handler if any
        const existingContainerHandler = modalContainerHandlers.get(container);
        if (existingContainerHandler) {
          container.removeEventListener('click', existingContainerHandler);
        }
        
        const handleContainerClick = (e) => {
          // Don't stop propagation if clicking the close button
          const closeButton = e.target.closest('.pickaxe-modal__close, .modal__close, .rebirth-modal__close');
          if (!closeButton) {
            e.stopPropagation();
          }
        };
        
        container.addEventListener('click', handleContainerClick);
        modalContainerHandlers.set(container, handleContainerClick);
      }
      
      // Note: MODAL_OPENED is already sent from button click handlers
      // This ensures the modal state is set before any click processing
      // No need to send it again here
    };

    const hideModal = (el) => {
      if (!el) return;
      el.classList.remove('visible');
      
      // Remove background click listener using stored reference
      const backgroundHandler = modalBackgroundHandlers.get(el);
      if (backgroundHandler) {
        el.removeEventListener('click', backgroundHandler);
        modalBackgroundHandlers.delete(el);
      }
      
      // Remove container click listener
      const container = el.querySelector('.pickaxe-modal__container');
      if (container) {
        const containerHandler = modalContainerHandlers.get(container);
        if (containerHandler) {
          container.removeEventListener('click', containerHandler);
          modalContainerHandlers.delete(container);
        }
      }
      
      // Notify server that a modal is closed (allows manual mining again)
      if (el.id === 'miner-modal') {
        hytopia.sendData({ type: 'MODAL_CLOSED', modalType: 'miner' });
      } else if (el.id === 'pickaxe-modal') {
        hytopia.sendData({ type: 'MODAL_CLOSED', modalType: 'pickaxe' });
      } else if (el.id === 'rebirth-modal') {
        hytopia.sendData({ type: 'MODAL_CLOSED', modalType: 'rebirth' });
      } else if (el.id === 'pets-modal') {
        hytopia.sendData({ type: 'MODAL_CLOSED', modalType: 'pets' });
      } else if (el.id === 'egg-modal') {
        hytopia.sendData({ type: 'MODAL_CLOSED', modalType: 'egg' });
      }
    };

    const renderPickaxeDetails = () => {
      // Show selected pickaxe, or equipped if none selected
      let pickaxeToShow = null;
      
      if (state.pickaxe.selectedTier !== undefined) {
        pickaxeToShow = state.pickaxe.pickaxes.find(p => p.tier === state.pickaxe.selectedTier);
      }
      
      if (!pickaxeToShow) {
        // Fallback to equipped pickaxe
        pickaxeToShow = state.pickaxe.pickaxes.find(p => p.availability === 'equipped');
      }
      
      if (!pickaxeToShow) {
        // Fallback to current tier
        pickaxeToShow = state.pickaxe.pickaxes.find(p => p.tier === state.pickaxe.currentTier);
      }
      
      if (pickaxeToShow) {
        renderEquippedPickaxe(pickaxeToShow);
      }
    };

    const renderEquippedPickaxe = (pickaxe) => {
      if (!pickaxe) return;
      
      // Update name
      if (pickaxeDetailName) {
        pickaxeDetailName.textContent = `${pickaxe.name} Pickaxe`;
      }

      // Update stats display (per planning document format)
      // REBALANCED: Pickaxes now only affect Speed, Luck, and Sell Value Multiplier
      if (pickaxeDetailStats) {
        pickaxeDetailStats.innerHTML = '';
        
        // Speed (display as percentage increase, e.g., "+5 Speed" means +5% speed)
        const speed = pickaxe.miningSpeed ? Math.round(pickaxe.miningSpeed) : 0;
        const speedStat = document.createElement('div');
        speedStat.className = 'pickaxe-stat pickaxe-stat--speed';
        speedStat.textContent = `+${speed} Speed`;
        pickaxeDetailStats.appendChild(speedStat);
        
        // Luck bonus
        const luckBonus = pickaxe.luckBonus ? (pickaxe.luckBonus * 100).toFixed(0) : '0';
        const luckStat = document.createElement('div');
        luckStat.className = 'pickaxe-stat pickaxe-stat--luck';
        luckStat.textContent = `+${luckBonus}% Ore Luck`;
        pickaxeDetailStats.appendChild(luckStat);
        
        // Sell Value Multiplier
        const sellMultiplier = pickaxe.sellValueMultiplier ? pickaxe.sellValueMultiplier.toFixed(2) : '1.00';
        const sellStat = document.createElement('div');
        sellStat.className = 'pickaxe-stat pickaxe-stat--sell';
        sellStat.textContent = `${sellMultiplier}√ó Sell Value`;
        pickaxeDetailStats.appendChild(sellStat);
      }

      // Action button logic
      // IMPORTANT: Do NOT cache the action button element globally.
      // We replace it when updating listeners (clone/remove), so we must re-query it each render.
      const pickaxeActionButtonEl = document.getElementById('pickaxe-action-button');
      if (pickaxeActionButtonEl) {
        // Remove existing click listeners by cloning
        const newButton = pickaxeActionButtonEl.cloneNode(true);
        pickaxeActionButtonEl.parentNode.replaceChild(newButton, pickaxeActionButtonEl);
        const actionButton = document.getElementById('pickaxe-action-button');
        
        if (pickaxe.availability === 'equipped') {
          // Currently equipped - show "Equipped" text (not a button)
          actionButton.textContent = 'Equipped';
          actionButton.classList.add('disabled');
          actionButton.disabled = true;
        } else if (pickaxe.availability === 'owned') {
          // Player owns this pickaxe but it's not equipped - show green Equip button
          actionButton.textContent = 'Equip';
          actionButton.classList.remove('disabled');
          actionButton.disabled = false;
          actionButton.dataset.tier = String(pickaxe.tier);
          actionButton.addEventListener('click', () => {
            console.log(`[UI] Equip pickaxe tier ${pickaxe.tier} from action button`);
            hytopia.sendData({ type: 'EQUIP_PICKAXE', tier: pickaxe.tier });
          });
        } else if (pickaxe.availability === 'available') {
          // Next tier available - show buy button with cost, grey out if can't afford
          actionButton.textContent = `ü™ô ${formatNumber(pickaxe.cost)}`;
          actionButton.disabled = false;
          if (!pickaxe.purchasable) {
            actionButton.classList.add('disabled');
          } else {
            actionButton.classList.remove('disabled');
          }
          actionButton.dataset.tier = String(pickaxe.tier);
          actionButton.addEventListener('click', () => {
            if (pickaxe.purchasable) {
              console.log(`[UI] Buy pickaxe tier ${pickaxe.tier} from action button`);
              hytopia.sendData({ type: 'BUY_PICKAXE', tier: pickaxe.tier });
            }
          });
        } else {
          // Locked - show locked state
          actionButton.textContent = 'Locked';
          actionButton.classList.add('disabled');
          actionButton.disabled = true;
        }
      }
    };

    const renderPickaxeGrid = () => {
      if (!pickaxeGridEl) return;
      pickaxeGridEl.innerHTML = '';
      const currentTier = state.pickaxe.currentTier;
      
      state.pickaxe.pickaxes.forEach(p => {
        const card = document.createElement('div');
        card.className = 'pickaxe-card';
        
        // Determine state based on availability from backend
        const isEquipped = p.availability === 'equipped';
        const isOwned = p.availability === 'owned';
        const isAvailable = p.availability === 'available';
        const isLocked = p.availability === 'locked';
        const isNextTier = p.tier === currentTier + 1;

        // Apply appropriate classes
        if (isEquipped) {
          card.classList.add('equipped');
        } else if (isOwned) {
          card.classList.add('purchased'); // Owned but not equipped - normal appearance
        } else if (isAvailable) {
          card.classList.add('next-tier'); // Available to purchase
        } else if (isLocked) {
          card.classList.add('locked'); // Greyed out with lock
        }

        const iconEl = document.createElement('div');
        iconEl.className = 'pickaxe-card__icon';
        iconEl.textContent = '‚õèÔ∏è';
        card.appendChild(iconEl);

        const nameEl = document.createElement('div');
        nameEl.className = 'pickaxe-card__name';
        nameEl.textContent = p.name;
        card.appendChild(nameEl);

        // Cost display (only if not equipped and not owned)
        if (!isEquipped && !isOwned) {
          const costEl = document.createElement('div');
          costEl.className = 'pickaxe-card__cost';
          costEl.innerHTML = `<span>ü™ô</span> ${formatNumber(p.cost)}`;
          card.appendChild(costEl);
        }

        // No buy/equip buttons on cards - all interactions happen in sidebar

        // Equipped checkmark
        if (isEquipped) {
          const checkmark = document.createElement('div');
          checkmark.className = 'pickaxe-card__checkmark';
          checkmark.textContent = '‚úì';
          card.appendChild(checkmark);
        }

        // Lock icon (if locked)
        if (isLocked) {
          const lock = document.createElement('div');
          lock.className = 'pickaxe-card__lock';
          lock.textContent = 'üîí';
          card.appendChild(lock);
        }

        // Highlight selected card
        if (state.pickaxe.selectedTier === p.tier) {
          card.classList.add('selected');
        }

        // Click to select (for details view) - for all pickaxes
        card.addEventListener('click', () => {
          state.pickaxe.selectedTier = p.tier;
          renderPickaxeGrid();
          renderPickaxeDetails();
        });

        pickaxeGridEl.appendChild(card);
      });
    };

    const updatePickaxeModal = (data) => {
      state.pickaxe.pickaxes = data.pickaxes || [];
      state.pickaxe.currentTier = data.currentTier ?? 0;
      state.gold = data.gold ?? state.gold;

      // If no selection, select the equipped pickaxe
      if (state.pickaxe.selectedTier === undefined || state.pickaxe.selectedTier === -1) {
        const equipped = state.pickaxe.pickaxes.find(p => p.availability === 'equipped');
        state.pickaxe.selectedTier = equipped ? equipped.tier : (state.pickaxe.currentTier >= 0 ? state.pickaxe.currentTier : (data.pickaxes && data.pickaxes.length > 0 ? data.pickaxes[0].tier : 0));
      }

      renderPickaxeGrid();
      renderPickaxeDetails();
      showModal(pickaxeModal);
    };

    const renderMinerDetails = () => {
      // Show selected miner, or equipped if none selected
      let minerToShow = null;
      
      if (state.miner.selectedTier !== undefined && state.miner.selectedTier !== -1) {
        minerToShow = state.miner.miners.find(m => m.tier === state.miner.selectedTier);
      }
      
      if (!minerToShow) {
        // Fallback to equipped miner
        minerToShow = state.miner.miners.find(m => m.availability === 'equipped');
      }
      
      if (minerToShow) {
        renderEquippedMiner(minerToShow);
      } else {
        renderEquippedMiner(null);
      }
    };

    const renderEquippedMiner = (miner) => {
      const minerActionButton = document.getElementById('miner-action-button');
      if (!minerDetailName || !minerDetailStats || !minerActionButton || !minerDetailIcon) return;

      if (!miner) {
        // No miner equipped
        minerDetailIcon.textContent = '‚õëÔ∏è';
        minerDetailName.textContent = 'No Miner';
        minerDetailStats.innerHTML = '';
        if (minerActionButton) {
          minerActionButton.textContent = 'No Miner';
          minerActionButton.classList.add('disabled');
          minerActionButton.disabled = true;
        }
        return;
      }

      minerDetailIcon.textContent = '‚õëÔ∏è';
      minerDetailName.textContent = miner.name;
      
      // Clear and rebuild stats with proper styling classes
      minerDetailStats.innerHTML = '';
      
      // Coin Bonus
      const coinStat = document.createElement('div');
      coinStat.className = 'pickaxe-stat pickaxe-stat--sell';
      coinStat.textContent = `+${miner.coinBonus}% Coins`;
      minerDetailStats.appendChild(coinStat);
      
      // Ore Luck Bonus
      const luckStat = document.createElement('div');
      luckStat.className = 'pickaxe-stat pickaxe-stat--luck';
      luckStat.textContent = `+${miner.oreLuckBonus}% Ore Luck`;
      minerDetailStats.appendChild(luckStat);
      
      // Damage Bonus
      const damageStat = document.createElement('div');
      damageStat.className = 'pickaxe-stat pickaxe-stat--damage';
      damageStat.textContent = `+${miner.damageBonus}% Damage`;
      minerDetailStats.appendChild(damageStat);
      
      // Action button logic
      if (minerActionButton) {
        // Remove existing click listeners by cloning
        const newButton = minerActionButton.cloneNode(true);
        minerActionButton.parentNode.replaceChild(newButton, minerActionButton);
        const actionButton = document.getElementById('miner-action-button');
        
        if (miner.availability === 'equipped') {
          // Currently equipped - show "Equipped" text (not a button)
          actionButton.textContent = 'Equipped';
          actionButton.classList.add('disabled');
          actionButton.disabled = true;
        } else if (miner.availability === 'owned') {
          // Player owns this miner but it's not equipped - show green Equip button
          actionButton.textContent = 'Equip';
          actionButton.classList.remove('disabled');
          actionButton.disabled = false;
          actionButton.dataset.tier = String(miner.tier);
          actionButton.addEventListener('click', () => {
            console.log(`[UI] Equip miner tier ${miner.tier} from action button`);
            hytopia.sendData({ type: 'EQUIP_MINER', tier: miner.tier });
          });
        } else if (miner.availability === 'available') {
          // Next tier available - show buy button with cost, grey out if can't afford
          actionButton.textContent = `ü™ô ${formatNumber(miner.cost)}`;
          actionButton.disabled = false;
          if (!miner.purchasable) {
            actionButton.classList.add('disabled');
          } else {
            actionButton.classList.remove('disabled');
          }
          actionButton.dataset.tier = String(miner.tier);
          actionButton.addEventListener('click', () => {
            if (miner.purchasable) {
              console.log(`[UI] Buy miner tier ${miner.tier} from action button`);
              hytopia.sendData({ type: 'BUY_MINER', tier: miner.tier });
            }
          });
        } else {
          // Locked - show locked state
          actionButton.textContent = 'Locked';
          actionButton.classList.add('disabled');
          actionButton.disabled = true;
        }
      }
    };

    const renderMinerGrid = () => {
      if (!minerGridEl) return;
      minerGridEl.innerHTML = '';

      const currentTier = state.miner.currentTier;
      const gold = state.gold;

      state.miner.miners.forEach(m => {
        const card = document.createElement('div');
        card.className = 'pickaxe-card';
        
        // Determine state based on availability from backend
        const isEquipped = m.availability === 'equipped';
        const isOwned = m.availability === 'owned';
        const isAvailable = m.availability === 'available';
        const isLocked = m.availability === 'locked';

        // Apply appropriate classes (similar to pickaxe grid)
        if (isEquipped) {
          card.classList.add('equipped');
        } else if (isOwned) {
          card.classList.add('purchased'); // Owned but not equipped - normal appearance
        } else if (isAvailable) {
          card.classList.add('next-tier'); // Available to purchase
        } else if (isLocked) {
          card.classList.add('locked'); // Greyed out with lock
        }

        const iconEl = document.createElement('div');
        iconEl.className = 'pickaxe-card__icon';
        iconEl.textContent = '‚õëÔ∏è';
        card.appendChild(iconEl);

        const nameEl = document.createElement('div');
        nameEl.className = 'pickaxe-card__name';
        nameEl.textContent = m.name;
        card.appendChild(nameEl);

        // Cost display (only if not equipped and not owned)
        if (!isEquipped && !isOwned) {
          const costEl = document.createElement('div');
          costEl.className = 'pickaxe-card__cost';
          costEl.innerHTML = `<span>ü™ô</span> ${formatNumber(m.cost)}`;
          card.appendChild(costEl);
        }

        // No buy/equip buttons on cards - all interactions happen in sidebar

        // Equipped checkmark
        if (isEquipped) {
          const checkmark = document.createElement('div');
          checkmark.className = 'pickaxe-card__checkmark';
          checkmark.textContent = '‚úì';
          card.appendChild(checkmark);
        }

        // Lock icon (if locked)
        if (isLocked) {
          const lock = document.createElement('div');
          lock.className = 'pickaxe-card__lock';
          lock.textContent = 'üîí';
          card.appendChild(lock);
        }

        // Highlight selected card
        if (state.miner.selectedTier === m.tier) {
          card.classList.add('selected');
        }

        card.addEventListener('click', () => {
          state.miner.selectedTier = m.tier;
          renderMinerGrid();
          renderMinerDetails();
        });

        minerGridEl.appendChild(card);
      });
    };

    const updateMinerModal = (data) => {
      state.miner.miners = data.miners || [];
      state.miner.currentTier = data.currentTier ?? -1;
      state.gold = data.gold ?? state.gold;
      
      // If no selection, select the equipped miner
      if (state.miner.selectedTier === undefined || state.miner.selectedTier === -1) {
        const equipped = state.miner.miners.find(m => m.availability === 'equipped');
        state.miner.selectedTier = equipped ? equipped.tier : (state.miner.currentTier >= 0 ? state.miner.currentTier : (data.miners && data.miners.length > 0 ? data.miners[0].tier : -1));
      }
      
      renderMinerGrid();
      renderMinerDetails();
      showModal(minerModal);
    };

    const renderRebirthOptions = () => {
      if (!rebirthOptionsEl) return;
      rebirthOptionsEl.innerHTML = '';
      
      // Sort options by count (1, 5, 20)
      const sortedOptions = [...state.rebirth.options].sort((a, b) => a.count - b.count);

      sortedOptions.forEach(opt => {
        const card = document.createElement('div');
        card.className = 'rebirth-option';

        // Left side: Rebirth count and cost
        const info = document.createElement('div');
        info.className = 'rebirth-option__info';
        
        const title = document.createElement('div');
        title.className = 'rebirth-option__title';
        // Format the count using formatNumber for readability (e.g., "1K Rebirths" instead of "1000 Rebirths")
        const formattedCount = formatNumber(opt.count);
        title.textContent = `${formattedCount} Rebirth${opt.count > 1 ? 's' : ''}`;
        info.appendChild(title);
        
        const cost = document.createElement('div');
        cost.className = 'rebirth-option__cost';
        cost.textContent = `${formatNumber(opt.cost)} Power`;
        info.appendChild(cost);
        
        card.appendChild(info);

        // Right side: Button
        const actionWrapper = document.createElement('div');
        actionWrapper.className = 'rebirth-option__action';
        const btn = document.createElement('button');
        btn.className = 'rebirth-button';
        btn.textContent = 'Rebirth';
        const affordable = state.power >= opt.cost;
        if (!affordable) {
          btn.classList.add('disabled');
          card.classList.add('unavailable');
        }
        btn.addEventListener('click', () => {
          if (!affordable) return;
          console.log(`[UI] Performing rebirth: ${opt.count}`);
          hytopia.sendData({ type: 'PERFORM_REBIRTH', rebirthCount: opt.count });
        });
        actionWrapper.appendChild(btn);
        card.appendChild(actionWrapper);

        rebirthOptionsEl.appendChild(card);
      });
    };

    const updateRebirthModal = (data) => {
      state.power = data.currentPower ?? state.power;
      state.rebirths = data.currentRebirths ?? state.rebirths;
      state.rebirth.options = data.options || [];
      state.rebirth.maxRebirths = data.maxRebirths ?? 0;
      renderRebirthOptions();
      showModal(rebirthModal);
      if (rebirthBadge) rebirthBadge.hidden = !(data.canRebirth);
    };

    const spawnMinedOrePopup = (oreName, oreColor) => {
      const timestamp = Date.now();
      console.log(`[UI] spawnMinedOrePopup called with oreName: ${oreName}, oreColor: ${oreColor}, timestamp: ${timestamp}`);

      // Check for existing popups to see if they're being reused
      const existingPopups = minedOreLayerEl.querySelectorAll('.mined-ore-popup');
      if (existingPopups.length > 0) {
        console.log(`[UI] WARNING: ${existingPopups.length} existing ore popups found when spawning new one!`);
        existingPopups.forEach((popup, index) => {
          console.log(`[UI] Existing popup ${index}: classes: ${popup.className}, text: ${popup.textContent}`);
        });
      }
      if (!minedOreLayerEl) {
        console.error('[UI] minedOreLayerEl not found! Cannot spawn popup.');
        return;
      }
      
      const popup = document.createElement('div');
      popup.className = 'mined-ore-popup';
      
      // Create text with + prefix
      const oreText = document.createElement('span');
      oreText.className = 'mined-ore-popup__text';
      oreText.textContent = `+${oreName}`;
      // Apply ore color if provided, otherwise use default white
      oreText.style.color = oreColor || '#ffffff';
      popup.appendChild(oreText);
      
      // Position above the block health bar name (centered, above the ore name)
      // Block health bar is at bottom: 120px, name is at the top of it
      // Position popup above the name text
      popup.style.left = '50%';
      popup.style.bottom = '220px'; // Above the ore name
      popup.style.transform = 'translateX(-50%)';
      
      minedOreLayerEl.appendChild(popup);
      
      // Force a reflow before adding active class
      popup.offsetHeight;
      
      // Add active class to trigger float up animation
      requestAnimationFrame(() => {
        popup.classList.add('active');
      });

      // Fade out and remove
      setTimeout(() => {
        popup.classList.add('fade-out');
        setTimeout(() => popup.remove(), 300); // Wait for fade out animation
      }, 900); // Total visible time ~1 second
    };

    const spawnPowerGain = (amount, rockPosition) => {
      console.log('[UI] spawnPowerGain called with amount:', amount, 'rockPosition:', rockPosition);
      if (!powerGainLayer) {
        console.error('[UI] powerGainLayer not found! Cannot spawn popup.');
        return;
      }
      console.log('[UI] powerGainLayer found, creating popup');
      
      const popup = document.createElement('div');
      popup.className = 'power-gain';
      
      // Add explosion icon and power amount
      const icon = document.createElement('span');
      icon.className = 'power-gain__icon';
      icon.textContent = 'üí•';
      popup.appendChild(icon);
      
      const text = document.createElement('span');
      text.className = 'power-gain__text';
      text.textContent = `+${Math.round(amount)}`;
      popup.appendChild(text);
      
      // Position popup near the rock if position is provided
      if (rockPosition && typeof hytopia !== 'undefined' && hytopia.worldToScreen) {
        try {
          // Convert world position to screen coordinates
          const screenPos = hytopia.worldToScreen(rockPosition.x, rockPosition.y + 2, rockPosition.z);
          if (screenPos && screenPos.x !== undefined && screenPos.y !== undefined) {
            // Position near the rock with slight random offset
            const offsetX = (Math.random() - 0.5) * 60; // -30 to +30 pixels
            const offsetY = (Math.random() - 0.5) * 60; // -30 to +30 pixels
            popup.style.left = `${screenPos.x + offsetX}px`;
            popup.style.top = `${screenPos.y + offsetY}px`;
            popup.style.transform = 'translate(-50%, -50%) scale(0.8)';
          } else {
            // Fallback to center screen with random offset
            const centerX = window.innerWidth / 2;
            const centerY = window.innerHeight / 2;
            const offsetX = (Math.random() - 0.5) * 200;
            const offsetY = (Math.random() - 0.5) * 200;
            popup.style.left = `${centerX + offsetX}px`;
            popup.style.top = `${centerY + offsetY}px`;
            popup.style.transform = 'translate(-50%, -50%) scale(0.8)';
          }
        } catch (e) {
          console.warn('[UI] Failed to convert world to screen position:', e);
          // Fallback to center screen
          popup.style.left = '50%';
          popup.style.top = '50%';
          popup.style.transform = 'translate(-50%, -50%) scale(0.8)';
        }
      } else {
        // Fallback: center of screen with random offset
        const centerX = window.innerWidth / 2;
        const centerY = window.innerHeight / 2;
        const offsetX = (Math.random() - 0.5) * 200;
        const offsetY = (Math.random() - 0.5) * 200;
        popup.style.left = `${centerX + offsetX}px`;
        popup.style.top = `${centerY + offsetY}px`;
        popup.style.transform = 'translate(-50%, -50%) scale(0.8)';
      }
      
      powerGainLayer.appendChild(popup);
      
      // Force a reflow before adding active class
      popup.offsetHeight;
      
      // Add active class to trigger animation
      requestAnimationFrame(() => {
        popup.classList.add('active');
      });
      
      setTimeout(() => {
        popup.classList.remove('active');
        setTimeout(() => popup.remove(), 600); // Wait for fade out animation
      }, 1000); // Disappear after 1 second
    };

    const spawnDamagePopup = (damage) => {
      if (!damagePopupLayerEl) {
        console.error('[UI] damagePopupLayerEl not found! Cannot spawn damage popup.');
        return;
      }
      
      if (damage <= 0) {
        return; // Don't show popup for 0 damage
      }
      
      const popup = document.createElement('div');
      popup.className = 'damage-popup';
      
      // Format damage number (e.g., 1140000000 -> "1.14B")
      const formatDamage = (value) => {
        if (value >= 1000000000) {
          const bValue = value / 1000000000;
          return bValue.toFixed(2).replace(/\.?0+$/, '') + 'B';
        } else if (value >= 1000000) {
          const mValue = value / 1000000;
          return mValue.toFixed(2).replace(/\.?0+$/, '') + 'M';
        } else if (value >= 1000) {
          const kValue = value / 1000;
          return kValue.toFixed(2).replace(/\.?0+$/, '') + 'K';
        } else {
          return Math.round(value).toString();
        }
      };
      
      const damageText = document.createElement('span');
      damageText.className = 'damage-popup__text';
      damageText.textContent = `${formatDamage(damage)} Dmg`;
      popup.appendChild(damageText);
      
      // Position to the right of the HP bar (which is centered at bottom: 120px)
      // HP bar container is 300px wide, centered, so right edge is at 50% + 150px
      // Position damage popup to the right of the HP bar with some gap
      const hpBarCenter = window.innerWidth / 2;
      const hpBarRightEdge = hpBarCenter + 150; // HP bar container is 300px wide
      const gap = 240; // Gap between HP bar and damage popup (increased for more spacing)
      const leftPosition = hpBarRightEdge + gap + (Math.random() * 20 - 10); // Slight random variation
      const bottomOffset = 180 + (Math.random() * 10 - 5); // Same vertical position as HP bar with slight variation
      popup.style.left = `${leftPosition}px`;
      popup.style.bottom = `${bottomOffset}px`;
      
      damagePopupLayerEl.appendChild(popup);
      
      // Force a reflow before adding active class
      popup.offsetHeight;
      
      // Add active class to trigger animation
      requestAnimationFrame(() => {
        popup.classList.add('active');
      });
      
      setTimeout(() => {
        popup.classList.remove('active');
        setTimeout(() => popup.remove(), 400); // Wait for fade out animation after removing active class
      }, 1500); // Total duration: drift up for 1.5 seconds, then fade out
    };

    const renderTrainingPrompt = () => {
      if (!trainingPromptEl || !trainingPromptTitleEl || !trainingPromptSubtitleEl || !trainingPromptKeyEl) return;
      if (!state.prompt.visible) {
        trainingPromptEl.classList.remove('visible');
        return;
      }

      // Show "Hold E to interact" message
      trainingPromptTitleEl.textContent = state.prompt.rockName;
      trainingPromptSubtitleEl.textContent = `Hold ${state.prompt.actionKey || 'E'} to interact`;
      trainingPromptKeyEl.textContent = (state.prompt.actionKey || 'E').toUpperCase();
      trainingPromptEl.classList.toggle('locked', state.prompt.canTrain === false);
      trainingPromptEl.classList.add('visible');
    };

    // Setup button handlers
    const autoMineButton = document.getElementById('auto-mine-button');
    const autoTrainButton = document.getElementById('auto-train-button');
    const toSurfaceButton = document.getElementById('to-surface-button');

    // Ensure buttons don't have focus on load - blur them immediately
    if (autoMineButton) autoMineButton.blur();
    if (autoTrainButton) autoTrainButton.blur();
    if (toSurfaceButton) toSurfaceButton.blur();
    
    // Ensure body has focus for keyboard input
    if (document.body) {
      document.body.focus();
    }

  // Default auto-mine state to inactive (green) until server sends state
  if (autoMineButton) {
    // Prevent focus so space/enter (jump) don't trigger the button
    autoMineButton.setAttribute('tabindex', '-1');
    autoMineButton.setAttribute('role', 'button');
    
    // Prevent keyboard events from triggering the button
    autoMineButton.addEventListener('keydown', e => {
      // Only prevent Space and Enter from triggering the button
      // Let all other keys (WASD, etc.) pass through to the game
      if (e.code === 'Space' || e.code === 'Enter') {
        e.preventDefault();
        e.stopPropagation();
        return false;
      }
    });
    
    // Prevent mousedown from focusing the button
    autoMineButton.addEventListener('mousedown', e => {
      e.preventDefault();
      // Don't let mousedown focus the button
      autoMineButton.blur();
    });
    
    autoMineButton.classList.add('inactive');
    
    // Set up click handler - only trigger on actual mouse clicks, not keyboard
    autoMineButton.addEventListener('click', (e) => {
      // Only process if it's a mouse click (not keyboard activation)
      if (e.detail === 0) {
        // Keyboard activation, ignore it
        return;
      }
      
      console.log('[UI] AUTO MINE button clicked');
      // Optimistically toggle UI state for instant feedback
      const nextEnabled = !autoMineButton.classList.contains('active');
      updateAutoMineButton(nextEnabled);

      // Send data to server using correct Hytopia SDK method
      console.log('[UI] Sending TOGGLE_AUTO_MINE to server');
      hytopia.sendData({ type: 'TOGGLE_AUTO_MINE' });

      // Return focus to game so movement keys keep working
      autoMineButton.blur();
      window.focus();
    });
  }

    // Default auto-train state to inactive (green) until server sends state
    if (autoTrainButton) {
      // Prevent focus so space/enter (jump) don't trigger the button
      autoTrainButton.setAttribute('tabindex', '-1');
      autoTrainButton.setAttribute('role', 'button');
      
      // Prevent keyboard events from triggering the button
      autoTrainButton.addEventListener('keydown', e => {
        // Only prevent Space and Enter from triggering the button
        // Let all other keys (WASD, etc.) pass through to the game
        if (e.code === 'Space' || e.code === 'Enter') {
          e.preventDefault();
          e.stopPropagation();
          return false;
        }
      });
      
      // Prevent mousedown from focusing the button
      autoTrainButton.addEventListener('mousedown', e => {
        e.preventDefault();
        // Don't let mousedown focus the button
        autoTrainButton.blur();
      });
      
      autoTrainButton.classList.add('inactive');
      
      // Set up click handler - only trigger on actual mouse clicks, not keyboard
      autoTrainButton.addEventListener('click', (e) => {
        // Only process if it's a mouse click (not keyboard activation)
        if (e.detail === 0) {
          // Keyboard activation, ignore it
          return;
        }
        
        console.log('[UI] AUTO TRAIN button clicked');
        // Optimistically toggle UI state for instant feedback
        const nextEnabled = !autoTrainButton.classList.contains('active');
        updateAutoTrainButton(nextEnabled);

        // Send data to server using correct Hytopia SDK method
        console.log('[UI] Sending TOGGLE_AUTO_TRAIN to server');
        hytopia.sendData({ type: 'TOGGLE_AUTO_TRAIN' });

        // Return focus to game so movement keys keep working
        autoTrainButton.blur();
        window.focus();
      });
    }

    if (toSurfaceButton) {
      // Prevent focus so space/enter (jump) don't trigger the button
      toSurfaceButton.setAttribute('tabindex', '-1');
      toSurfaceButton.setAttribute('role', 'button');
      
      // Prevent keyboard events from triggering the button
      toSurfaceButton.addEventListener('keydown', e => {
        // Only prevent Space and Enter from triggering the button
        // Let all other keys (WASD, etc.) pass through to the game
        if (e.code === 'Space' || e.code === 'Enter') {
          e.preventDefault();
          e.stopPropagation();
          return false;
        }
      });
      
      // Prevent mousedown from focusing the button
      toSurfaceButton.addEventListener('mousedown', e => {
        e.preventDefault();
        // Don't let mousedown focus the button
        toSurfaceButton.blur();
      });
      
      // Set up click handler - only trigger on actual mouse clicks, not keyboard
      toSurfaceButton.addEventListener('click', (e) => {
        // Only process if it's a mouse click (not keyboard activation)
        if (e.detail === 0) {
          // Keyboard activation, ignore it
          return;
        }
        
        console.log('[UI] TELEPORT TO SURFACE button clicked');
        hytopia.sendData({ type: 'TELEPORT_TO_SURFACE' });

        // Return focus to game so movement keys keep working
        toSurfaceButton.blur();
        window.focus();
      });
    }

    function updateProgressBar(currentDepth, goalDepth) {
      const progressBarFillEl = document.getElementById('progress-bar-fill');
      const progressBarMarkerEl = document.getElementById('progress-bar-marker');
      const progressBarEl = document.getElementById('progress-bar');

      if (!progressBarFillEl || !progressBarMarkerEl || !progressBarEl) return;

      const progress = Math.min(100, (currentDepth / goalDepth) * 100);
      progressBarFillEl.style.width = `${progress}%`;
      progressBarMarkerEl.style.left = `${progress}%`;
    }

    function updateAutoMineButton(enabled) {
      if (!autoMineButton) return;
      if (enabled) {
        autoMineButton.classList.add('active');
        autoMineButton.classList.remove('inactive');
      } else {
        autoMineButton.classList.remove('active');
        autoMineButton.classList.add('inactive');
      }
    }

    function updateAutoTrainButton(enabled) {
      if (!autoTrainButton) return;
      if (enabled) {
        autoTrainButton.classList.add('active');
        autoTrainButton.classList.remove('inactive');
      } else {
        autoTrainButton.classList.remove('active');
        autoTrainButton.classList.add('inactive');
      }
    }

    hytopia.onData(data => {
      console.log('[UI] Received data:', data.type, data);
      switch (data.type) {
        case 'POWER_STATS':
          state.power = data.power ?? 0;
          state.gold = data.gold ?? state.gold;
          state.gems = data.gems ?? state.gems;
          state.wins = data.wins ?? state.wins;
          state.rebirths = data.rebirths ?? state.rebirths;
          if (powerValueEl) powerValueEl.textContent = formatNumber(state.power);
          if (moneyValueEl) moneyValueEl.textContent = formatNumber(state.gold);
          if (gemsValueEl) gemsValueEl.textContent = formatNumber(state.gems);
          if (winsValueEl) winsValueEl.textContent = formatNumber(state.wins);
          if (rebirthsValueEl) rebirthsValueEl.textContent = formatNumber(state.rebirths);
          console.log('[UI] Updated stats - power:', state.power, 'gold:', state.gold, 'gems:', state.gems, 'wins:', state.wins, 'rebirths:', state.rebirths);
          break;
        case 'GOLD_STATS':
          state.gold = data.gold ?? 0;
          if (moneyValueEl) moneyValueEl.textContent = formatNumber(state.gold);
          console.log('[UI] Updated gold stats:', state.gold);
          break;
        case 'GEMS_STATS':
          state.gems = data.gems ?? 0;
          if (gemsValueEl) gemsValueEl.textContent = formatNumber(state.gems);
          console.log('[UI] Updated gems stats:', state.gems);
          break;
        case 'WINS_STATS':
          state.wins = data.wins ?? 0;
          if (winsValueEl) winsValueEl.textContent = formatNumber(state.wins);
          console.log('[UI] Updated wins stats:', state.wins);
          break;
        case 'REBIRTHS_STATS':
          state.rebirths = data.rebirths ?? 0;
          if (rebirthsValueEl) rebirthsValueEl.textContent = formatNumber(state.rebirths);
          console.log('[UI] Updated rebirths stats:', state.rebirths);
          break;
        case 'POWER_GAIN':
          console.log('[UI] Processing POWER_GAIN:', data);
          state.power = data.totalPower ?? state.power + (data.amount ?? 0);
          console.log('[UI] New power total:', state.power);
          if (powerValueEl) {
            powerValueEl.textContent = formatNumber(state.power);
            console.log('[UI] Updated power value element');
          } else {
            console.warn('[UI] powerValueEl is null!');
          }
          if (typeof data.amount === 'number' && data.amount > 0) {
            console.log('[UI] Spawning power gain popup:', data.amount, 'at rock position:', data.rockPosition);
            spawnPowerGain(data.amount, data.rockPosition);
          } else {
            console.warn('[UI] Invalid amount for popup:', data.amount);
          }
          break;
        case 'TRAINING_PROMPT':
          // Show or hide the training prompt based on visibility
          state.prompt.visible = data.visible ?? false;
          if (data.visible) {
            // Update prompt data when showing
            state.prompt.rockName = data.rockName || 'Training Rock';
            state.prompt.requirements = data.requirements || { power: 0, rebirths: 0 };
            state.prompt.canTrain = data.canTrain ?? false;
            state.prompt.actionKey = data.actionKey || 'E';
          }
          renderTrainingPrompt();
          break;
        case 'MINING_STATE':
          state.mining.isMining = data.isMining ?? false;
          if (miningHudEl) {
            if (state.mining.isMining) {
              miningHudEl.classList.add('visible');
            } else {
              miningHudEl.classList.remove('visible');
            }
          }
          break;
        case 'MERCHANT_PROXIMITY':
          console.log('[UI] Merchant proximity:', data.inProximity);
          state.gold = data.gold ?? state.gold;
          if (moneyValueEl) moneyValueEl.textContent = formatNumber(state.gold);
          const merchantUI = document.getElementById('merchant-ui');
          if (merchantUI) {
            if (data.inProximity) {
              merchantUI.classList.add('visible');
              updateMerchantUI(data.inventory || {}, data.totalValue || 0, data.gold || 0, data.oreSellValues || {});
            } else {
              merchantUI.classList.remove('visible');
            }
          }
          break;
        case 'MINE_RESET_UPGRADE_PROXIMITY':
          console.log('[UI] Mine Reset Upgrade proximity:', data.inProximity);
          state.gold = data.gold ?? state.gold;
          if (moneyValueEl) moneyValueEl.textContent = formatNumber(state.gold);
          const upgradeUI = document.getElementById('mine-reset-upgrade-ui');
          if (upgradeUI) {
            if (data.inProximity) {
              upgradeUI.classList.add('visible');
              updateMineResetUpgradeUI(
                data.hasUpgrade ?? false,
                data.cost ?? 2_000_000,
                data.gold ?? 0
              );
            } else {
              upgradeUI.classList.remove('visible');
            }
          }
          break;
        case 'GEM_TRADER_PROXIMITY':
          console.log('[UI] Gem Trader proximity:', data.inProximity);
          state.gems = data.gems ?? state.gems;
          if (gemsValueEl) gemsValueEl.textContent = formatNumber(state.gems);
          const gemTraderUI = document.getElementById('gem-trader-ui');
          if (gemTraderUI) {
            if (data.inProximity) {
              gemTraderUI.classList.add('visible');
              updateGemTraderUI(data.upgrades || {}, data.gems || 0);
            } else {
              gemTraderUI.classList.remove('visible');
            }
          }
          break;
        case 'EGG_STATION_PROXIMITY': {
          // Server-driven proximity: show/hide egg modal
          if (!data.inProximity) {
            state.eggStation.inProximity = false;
            state.eggStation.stationId = null;
            stopEggAuto();
            if (eggModal) hideModal(eggModal);
            break;
          }

          state.eggStation.inProximity = true;
          state.eggStation.stationId = data.station?.id ?? null;
          state.eggStation.stationName = data.station?.name ?? 'Egg Station';
          state.eggStation.eggType = data.station?.eggType ?? 'stone';
          state.eggStation.defaultOpenCount = data.station?.defaultOpenCount ?? 1;
          state.eggStation.costGold = data.station?.costGold ?? 0;

          // Update gold + pet counts snapshot (for display)
          if (typeof data.player?.gold === 'number') {
            state.gold = data.player.gold;
            if (moneyValueEl) moneyValueEl.textContent = formatNumber(state.gold);
          }
          if (typeof data.player?.petInventoryCount === 'number') {
            state.pets.ownedCount = data.player.petInventoryCount;
          }
          if (typeof data.player?.petInventoryCap === 'number') {
            state.pets.ownedCap = data.player.petInventoryCap;
          }
          if (typeof data.player?.petEquippedCount === 'number') {
            state.pets.equippedCount = data.player.petEquippedCount;
          }
          if (typeof data.player?.petEquippedCap === 'number') {
            state.pets.equippedCap = data.player.petEquippedCap;
          }

          // Open modal and block manual mining clicks
          if (eggModal && !eggModal.classList.contains('visible')) {
            hytopia.sendData({ type: 'MODAL_OPENED', modalType: 'egg' });
            showModal(eggModal);
            // Refresh pets immediately so inventory/equipped counts are accurate
            hytopia.sendData({ type: 'REQUEST_PET_STATE' });
          }
          renderEggStation();
          break;
        }
        case 'EGG_HATCH_RESULT': {
          if (!data.success) {
            console.log('[UI] Egg hatch failed:', data.message);
            // Stop auto if we can't hatch (insufficient gold, inventory full, etc.)
            stopEggAuto();
            if (eggStationStatusEl) {
              eggStationStatusEl.textContent = data.message || 'Failed';
            }
            break;
          }

          state.eggStation.lastHatch = data.results || [];
          if (typeof data.goldSpent === 'number') {
            // GOLD_STATS will also come from server, this just keeps UI snappy if it arrives late
            state.gold = Math.max(0, state.gold - data.goldSpent);
            if (moneyValueEl) moneyValueEl.textContent = formatNumber(state.gold);
          }
          renderEggStation();
          break;
        }
        case 'PET_STATE':
          state.pets.pets = data.pets || [];
          state.pets.ownedCount = data.ownedCount ?? state.pets.ownedCount;
          state.pets.ownedCap = data.ownedCap ?? state.pets.ownedCap;
          state.pets.equippedCount = data.equippedCount ?? state.pets.equippedCount;
          state.pets.equippedCap = data.equippedCap ?? state.pets.equippedCap;
          state.pets.multiplierSum = data.multiplierSum ?? 0;
          state.pets.trainingMultiplier = data.trainingMultiplier ?? 1;
          renderPets();
          // Egg modal also displays pet inventory count, so refresh it too
          renderEggStation();
          break;
        case 'PET_ACTION_RESULT':
          if (!data.success) {
            console.log('[UI] Pet action failed:', data.message);
          }
          break;
        case 'UPGRADE_PURCHASED':
          console.log('[UI] Upgrade purchased:', data);
          state.gems = data.remainingGems ?? state.gems;
          if (gemsValueEl) gemsValueEl.textContent = formatNumber(state.gems);
          // Refresh the UI by requesting updated data (if UI is visible)
          const gemTraderUIVisible = document.getElementById('gem-trader-ui')?.classList.contains('visible');
          if (gemTraderUIVisible && data.success) {
            // Request refresh - in a real implementation, we'd re-request the data
            // For now, the server will send GEM_TRADER_PROXIMITY again to refresh
            console.log('[UI] Upgrade purchased successfully, UI should refresh');
          }
          break;
        case 'MINE_RESET_UPGRADE_PURCHASED':
          console.log('[UI] Mine Reset Upgrade purchase result:', data);
          state.gold = data.remainingGold ?? state.gold;
          if (moneyValueEl) moneyValueEl.textContent = formatNumber(state.gold);
          const upgradeUIVisible = document.getElementById('mine-reset-upgrade-ui')?.classList.contains('visible');
          if (upgradeUIVisible) {
            // Always update with the hasUpgrade flag from server
            updateMineResetUpgradeUI(
              data.hasUpgrade ?? true, // Default to true if purchase was successful
              data.cost ?? 2_000_000,
              data.remainingGold ?? 0
            );
          }
          break;
        case 'INVENTORY_UPDATE':
          console.log('[UI] Inventory update received');
          state.gold = data.gold ?? state.gold;
          if (moneyValueEl) moneyValueEl.textContent = formatNumber(state.gold);
          const merchantUIVisible = document.getElementById('merchant-ui')?.classList.contains('visible');
          if (merchantUIVisible) {
            updateMerchantUI(data.inventory || {}, data.totalValue || 0, data.gold || 0, data.oreSellValues || {});
            if (data.goldEarned && data.goldEarned > 0) {
              // Show gold earned notification
              console.log(`[UI] Gold earned: ${data.goldEarned}`);
            }
          }
          break;
        case 'MINING_UPDATE':
          state.mining.damage = data.damage ?? 0;
          state.mining.currentOre = data.currentOreName ?? null;
          const blockHP = data.blockHP ?? 0;
          const maxHP = data.maxHP ?? 100;
          const isChest = data.isChest ?? false;
          const sellValue = data.sellValue ?? null;
          const gemReward = data.gemReward ?? null;
          
          // Spawn damage popup for each mining swing
          if (state.mining.damage > 0) {
            spawnDamagePopup(state.mining.damage);
          }

          // Spawn ore mined popup when block is destroyed (like damage popups)
          if (data.oreMined && data.oreMinedColor) {
            console.log(`[UI] MINING_UPDATE received ore mined: ${data.oreMined}, spawning popup (damage: ${data.damage}, blockHP: ${data.blockHP})`);
            spawnMinedOrePopup(data.oreMined, data.oreMinedColor);
          }

          // Update block health bar (bottom center, above progress bar)
          if (blockHealthBarEl && blockHealthBarNameEl && blockHealthBarFillEl && blockHealthBarTextEl && blockRewardDisplayEl) {
            // Store current block info if valid
            const oreColor = data.oreColor ?? null;
            let currentBlockInfo = null;
            if (state.mining.currentOre && blockHP > 0 && maxHP > 0) {
              currentBlockInfo = {
                name: state.mining.currentOre,
                blockHP: blockHP,
                maxHP: maxHP,
                isChest: isChest,
                sellValue: sellValue,
                gemReward: gemReward,
                color: oreColor // Store color for display
              };
              state.mining.lastBlockInfo = currentBlockInfo; // Update last known block
            }
            
            // Use current block info if available, otherwise use last known block info
            // This prevents UI from disappearing during fast mining transitions
            const displayInfo = currentBlockInfo || state.mining.lastBlockInfo;
            
            if (displayInfo) {
              // Update ALL content FIRST before showing (prevents flicker when switching ores quickly)
              // This ensures the UI never disappears - it just updates content instantly
              blockHealthBarNameEl.textContent = displayInfo.name;
              // Apply ore color if available (for ores, not chests)
              if (!displayInfo.isChest && displayInfo.color) {
                blockHealthBarNameEl.style.color = displayInfo.color;
              } else {
                // Use white for chests or if no color available
                blockHealthBarNameEl.style.color = '#fff';
              }
              blockHealthBarTextEl.textContent = `${Math.floor(displayInfo.blockHP).toLocaleString()}/${Math.floor(displayInfo.maxHP).toLocaleString()} HP`;
              
              // Calculate fill percentage
              const fillPercent = Math.max(0, Math.min(100, (displayInfo.blockHP / displayInfo.maxHP) * 100));
              blockHealthBarFillEl.style.width = `${fillPercent}%`;
              
              // Update reward display (sell value for ores, gem reward for chests)
              if (displayInfo.isChest && displayInfo.gemReward !== null && displayInfo.gemReward > 0) {
                // Display gem reward for chests
                blockRewardDisplayEl.innerHTML = `<span style="color: #4caf50;">üíé</span> <span style="color: #4caf50; font-weight: 700;">${formatNumber(displayInfo.gemReward)} Gems</span>`;
                blockRewardDisplayEl.style.display = 'flex';
              } else if (!displayInfo.isChest && displayInfo.sellValue !== null && displayInfo.sellValue > 0) {
                // Display sell value for ores
                blockRewardDisplayEl.innerHTML = `<span style="color: #ffd700;">ü™ô</span> <span style="color: #ffd700; font-weight: 700;">${formatNumber(displayInfo.sellValue)} Gold</span>`;
                blockRewardDisplayEl.style.display = 'flex';
              } else {
                blockRewardDisplayEl.style.display = 'none';
              }
              
              // Show UI instantly with no transition - ensures UI is always visible
              // Use both class and inline style to override any transitions
              blockHealthBarEl.style.opacity = '1';
              blockHealthBarEl.style.transition = 'none';
              blockHealthBarEl.classList.add('visible');
            } else {
              // Only hide if we truly have no block info at all
              // Clear last known block when leaving mine
              state.mining.lastBlockInfo = null;
              blockHealthBarEl.style.opacity = '0';
              blockHealthBarEl.style.transition = 'none';
              blockHealthBarEl.classList.remove('visible');
              blockRewardDisplayEl.style.display = 'none';
            }
          }
          
          // Old current ore display removed - now using mining target display
          
          // Update damage display (bottom middle right)
          if (damageDisplayEl) {
            if (state.mining.damage > 0) {
              damageDisplayEl.textContent = `${Math.round(state.mining.damage)} Dmg`;
              damageDisplayEl.classList.add('visible');
            } else {
              damageDisplayEl.classList.remove('visible');
            }
          }
          break;
        case 'PROGRESS_UPDATE':
          updateProgressBar(data.currentDepth ?? 0, data.goalDepth ?? 1000);
          break;
        case 'MINING_STATE_UPDATE':
          // Show/hide mining controls
          const miningControlsEl = document.getElementById('mining-controls');
          if (miningControlsEl) {
            if (data.isInMine) {
              miningControlsEl.classList.add('visible');
            } else {
              miningControlsEl.classList.remove('visible');
            }
          }
          
          // Clear block health bar when leaving mine
          if (!data.isInMine) {
            // Clear last known block info when leaving mine
            state.mining.lastBlockInfo = null;
            if (blockHealthBarEl) {
              blockHealthBarEl.style.opacity = '0';
              blockHealthBarEl.style.transition = 'none';
              blockHealthBarEl.classList.remove('visible');
            }
            if (blockRewardDisplayEl) {
              blockRewardDisplayEl.style.display = 'none';
            }
            if (damageDisplayEl) {
              damageDisplayEl.classList.remove('visible');
            }
          }
          break;
        case 'MINE_RESET_TIMER':
          // Update mine reset timer display
          if (mineResetTimerEl && mineResetTimerTextEl) {
            if (data.timeRemaining !== null && data.timeRemaining !== undefined) {
              mineResetTimerTextEl.textContent = `Mines will reset in: ${data.timeRemaining}`;
              mineResetTimerEl.classList.add('visible');
            } else {
              mineResetTimerEl.classList.remove('visible');
            }
          }
          break;
        case 'MINING_DEPTH_COUNTER':
          // Update mining depth counter display
          if (miningDepthCounterTextEl) {
            const depth = data.depth ?? 0;
            miningDepthCounterTextEl.textContent = `Depth: ${depth}`;
          }
          break;
        case 'AUTO_MINE_STATE':
          updateAutoMineButton(data.enabled ?? false);
          break;
        case 'AUTO_TRAIN_STATE':
          updateAutoTrainButton(data.enabled ?? false);
          break;
        case 'MINER_SHOP_DATA':
          updateMinerModal(data);
          break;
        case 'MINER_PURCHASED':
          if (data.success) {
            state.gold = data.remainingGold ?? state.gold;
            if (moneyValueEl) moneyValueEl.textContent = formatNumber(state.gold);
            // Refresh miner shop data
            hytopia.sendData({ type: 'OPEN_MINER_SHOP' });
          }
          break;
        case 'MINER_EQUIPPED':
          if (data.success) {
            // Refresh miner shop data and update the detail panel
            hytopia.sendData({ type: 'OPEN_MINER_SHOP' });
            // Also re-render details to update button state
            renderMinerDetails();
          }
          break;
        case 'PICKAXE_SHOP_DATA':
          console.log('[UI] Pickaxe shop data received');
          updatePickaxeModal(data);
          break;
        case 'PICKAXE_PURCHASED':
          console.log('[UI] Pickaxe purchase result:', data);
          if (data.success) {
            state.gold = data.remainingGold ?? state.gold;
            if (moneyValueEl) moneyValueEl.textContent = formatNumber(state.gold);
            // Update pickaxe state
            state.pickaxe.currentTier = data.newTier ?? state.pickaxe.currentTier;
            // Refresh shop data
            hytopia.sendData({ type: 'OPEN_PICKAXE_SHOP' });
          } else {
            console.warn('[UI] Pickaxe purchase failed:', data.message);
            // Could show error message to user here
          }
          break;
        case 'PICKAXE_EQUIPPED':
          console.log('[UI] Pickaxe equip result:', data);
          if (data.success) {
            // Update pickaxe state
            state.pickaxe.currentTier = data.newTier ?? state.pickaxe.currentTier;
            // Refresh shop data to update availability status
            hytopia.sendData({ type: 'OPEN_PICKAXE_SHOP' });
            // Also re-render details to update button state
            renderPickaxeDetails();
          } else {
            console.warn('[UI] Pickaxe equip failed:', data.message);
            // Could show error message to user here
          }
          break;
        case 'REBIRTH_UI_DATA':
          console.log('[UI] Rebirth UI data received');
          updateRebirthModal(data);
          break;
        case 'REBIRTH_COMPLETE':
          console.log('[UI] Rebirth complete:', data);
          if (data.success) {
            state.power = data.newPower ?? state.power;
            state.rebirths = data.newRebirths ?? state.rebirths;
            if (powerValueEl) powerValueEl.textContent = formatNumber(state.power);
            if (rebirthsValueEl) rebirthsValueEl.textContent = formatNumber(state.rebirths);
            // Refresh rebirth UI data
            hytopia.sendData({ type: 'OPEN_REBIRTH_UI' });
          } else {
            console.warn('[UI] Rebirth failed:', data.message);
          }
          break;
        default:
          console.log('[UI] Unknown event type:', data.type);
          break;
      }
    });
  }
</script>

<div class="ui-root">
  <div class="mobile-controls">
    <a id="mobile-interact-button" class="mobile-button">
      <img src="{{CDN_ASSETS_URL}}/icons/target.png" />
    </a>

    <a id="mobile-jump-button" class="mobile-button">
      <img src="{{CDN_ASSETS_URL}}/icons/jump.png" />
    </a>
  </div>

  <!-- Stats HUD Container (Middle Right) -->
  <div class="stats-hud-container">
    <!-- Trophy (Wins) -->
    <div class="stat-hud stat-hud--wins">
      <div class="stat-hud__value" id="wins-value">0</div>
      <div class="stat-hud__icon">üèÜ</div>
    </div>
    
    <!-- Money -->
    <div class="stat-hud stat-hud--money">
      <div class="stat-hud__value" id="money-value">0</div>
      <div class="stat-hud__icon">üí∞</div>
    </div>
    
    <!-- Gems -->
    <div class="stat-hud stat-hud--gems">
      <div class="stat-hud__value" id="gems-value">0</div>
      <div class="stat-hud__icon">üíé</div>
    </div>
    
    <!-- Power -->
    <div class="stat-hud stat-hud--power">
      <div class="stat-hud__value" id="power-value">0</div>
      <div class="stat-hud__icon">üí•</div>
    </div>
    
    <!-- Rebirths -->
    <div class="stat-hud stat-hud--rebirths">
      <div class="stat-hud__value" id="rebirths-value">0</div>
      <div class="stat-hud__icon">üîÑ</div>
    </div>
  </div>

  <!-- Left-side action buttons -->
  <div class="left-actions">
    <button id="miner-button" class="action-card action-card--miner">
      <span class="action-card__icon">‚õëÔ∏è</span>
    </button>
    <button id="pickaxe-button" class="action-card action-card--pickaxe">
      <span class="action-card__icon">‚õèÔ∏è</span>
    </button>
    <button id="rebirth-button" class="action-card action-card--rebirth">
      <span class="action-card__icon">üîÅ</span>
      <span class="action-card__badge" id="rebirth-badge" hidden>!</span>
    </button>
    <button id="pets-button" class="action-card action-card--pets">
      <span class="action-card__icon">üêæ</span>
    </button>
  </div>

  <!-- Miner Shop Modal -->
  <div id="miner-modal" class="modal pickaxe-modal miner-modal">
    <div class="pickaxe-modal__container">
      <div class="pickaxe-modal__header">
        <div class="pickaxe-modal__title">Miners</div>
        <button class="pickaxe-modal__close" data-close="miner-modal">√ó</button>
      </div>
      <div class="pickaxe-modal__body">
        <!-- Left Panel: Equipped Miner Details -->
        <div class="pickaxe-modal__left-panel">
          <div class="pickaxe-details">
            <div class="pickaxe-details__icon" id="miner-detail-icon">‚õëÔ∏è</div>
            <div class="pickaxe-details__name" id="miner-detail-name">No Miner</div>
            <div class="pickaxe-details__stats" id="miner-detail-stats"></div>
            <button class="pickaxe-details__action-button" id="miner-action-button">No Miner</button>
          </div>
        </div>
        <!-- Right Panel: Miner Grid -->
        <div class="pickaxe-modal__right-panel">
          <div class="pickaxe-grid" id="miner-grid"></div>
        </div>
      </div>
    </div>
  </div>

  <!-- Pickaxe Shop Modal -->
  <div id="pickaxe-modal" class="modal pickaxe-modal">
    <div class="pickaxe-modal__container">
      <div class="pickaxe-modal__header">
        <div class="pickaxe-modal__title">Pickaxe</div>
        <button class="pickaxe-modal__close" data-close="pickaxe-modal">√ó</button>
      </div>
      <div class="pickaxe-modal__body">
        <!-- Left Panel: Equipped Pickaxe Details -->
        <div class="pickaxe-modal__left-panel">
          <div class="pickaxe-details">
            <div class="pickaxe-details__icon" id="pickaxe-detail-icon">‚õèÔ∏è</div>
            <div class="pickaxe-details__name" id="pickaxe-detail-name">Pickaxe</div>
            <div class="pickaxe-details__stats" id="pickaxe-detail-stats"></div>
            <button class="pickaxe-details__action-button" id="pickaxe-action-button">Equipped</button>
          </div>
        </div>
        <!-- Right Panel: Pickaxe Grid -->
        <div class="pickaxe-modal__right-panel">
          <div class="pickaxe-grid" id="pickaxe-grid"></div>
        </div>
      </div>
    </div>
  </div>

  <!-- Rebirth Modal -->
  <div id="rebirth-modal" class="modal rebirth-modal">
    <div class="rebirth-modal__container">
      <div class="rebirth-modal__header">
        <div class="rebirth-modal__title">Rebirth</div>
        <button class="rebirth-modal__close" data-close="rebirth-modal">√ó</button>
      </div>
      <div class="rebirth-modal__body">
        <div class="rebirth-modal__instruction">Click a button to rebirth!</div>
        <div class="rebirth-modal__explanation">
          <span class="rebirth-icon">üîÑ</span>
          <span class="rebirth-text">1</span>
          <span class="rebirth-equals">=</span>
          <span class="power-icon">üí•</span>
          <span class="power-text">+10%</span>
        </div>
        <div class="rebirth-options" id="rebirth-options"></div>
      </div>
    </div>
  </div>

  <!-- Egg Station Modal -->
  <div id="egg-modal" class="modal pickaxe-modal egg-modal">
    <div class="pickaxe-modal__container">
      <div class="pickaxe-modal__header">
        <div class="pickaxe-modal__title" id="egg-modal-title">Egg Station</div>
        <button class="pickaxe-modal__close" data-close="egg-modal">√ó</button>
      </div>
      <div class="pickaxe-modal__body">
        <div class="pickaxe-modal__left-panel">
          <div class="pickaxe-details">
            <div class="pickaxe-details__icon">ü•ö</div>
            <div class="pickaxe-details__name" id="egg-station-name">Egg Station</div>
            <div class="pickaxe-details__stats" id="egg-station-stats">
              <div>Cost: <span id="egg-station-cost">0</span> gold</div>
              <div>Your gold: <span id="egg-station-gold">0</span></div>
              <div>Pets: <span id="egg-station-inv">0/50</span></div>
            </div>
            <div class="pickaxe-details__badge" id="egg-station-status">Ready</div>
          </div>
        </div>
        <div class="pickaxe-modal__right-panel">
          <div class="egg-actions">
            <button id="egg-open-1" class="rebirth-button">Open 1</button>
            <button id="egg-open-3" class="rebirth-button">Open 3</button>
            <button id="egg-auto" class="rebirth-button rebirth-button--max">Auto</button>
          </div>
          <div class="egg-results">
            <div class="egg-results__title">Last Hatch</div>
            <div id="egg-results-list" class="egg-results__list"></div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Pets Modal -->
  <div id="pets-modal" class="modal pickaxe-modal pets-modal">
    <div class="pickaxe-modal__container">
      <div class="pickaxe-modal__header">
        <div class="pickaxe-modal__title">Pets</div>
        <button class="pickaxe-modal__close" data-close="pets-modal">√ó</button>
      </div>
      <div class="pickaxe-modal__body">
        <div class="pets-topbar">
          <div class="pets-topbar__left">
            <div class="pets-pill">
              <span class="pets-pill__icon">üì¶</span>
              <span id="pets-owned-count">0/50</span>
            </div>
            <div class="pets-pill">
              <span class="pets-pill__icon">üêæ</span>
              <span id="pets-equipped-count">0/8</span>
            </div>
          </div>
          <div class="pets-topbar__right">
            <span class="pets-mult">x<span id="pets-multiplier-sum">1</span></span>
          </div>
        </div>

        <div class="pets-content">
          <div id="pets-grid" class="pets-grid"></div>

          <!-- Side detail panel (opens when a pet is selected) -->
          <div id="pet-detail-panel" class="pet-detail" hidden>
            <button id="pet-detail-close" class="pet-detail__close">√ó</button>
            <div id="pet-detail-name" class="pet-detail__name">Pet</div>
            <div class="pet-detail__card">
              <div id="pet-detail-image" class="pet-detail__image">üêæ</div>
              <div id="pet-detail-mult" class="pet-detail__mult">0</div>
            </div>
            <div id="pet-detail-rarity" class="pet-detail__rarity"></div>
            <button id="pet-detail-action" class="pet-detail__action pet-detail__action--equip">Equip</button>
          </div>
        </div>

        <div class="pets-footer">
          <button id="pets-equip-best" class="pets-footer__btn pets-footer__btn--green">Equip Best</button>
          <button id="pets-unequip-all" class="pets-footer__btn pets-footer__btn--red">Unequip All</button>
          <button id="pets-trash-toggle" class="pets-footer__icon" title="Delete pets">üóëÔ∏è</button>
        </div>

        <!-- Delete confirmation bar (appears in delete mode) -->
        <div id="pets-delete-bar" class="pets-delete-bar" hidden>
          <div id="pets-delete-text" class="pets-delete-bar__text">Delete 0 Pets!</div>
          <div class="pets-delete-bar__actions">
            <button id="pets-delete-confirm" class="pets-delete-bar__btn pets-delete-bar__btn--green">Confirm</button>
            <button id="pets-delete-cancel" class="pets-delete-bar__btn pets-delete-bar__btn--red">Cancel</button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <div id="training-prompt" class="training-prompt">
    <div id="training-prompt-key" class="training-prompt__key">E</div>
    <div class="training-prompt__copy">
      <div id="training-prompt-title" class="training-prompt__title">Interact</div>
      <div id="training-prompt-subtitle" class="training-prompt__subtitle">0 Power OR 0 Rebirths</div>
    </div>
  </div>

  <div id="power-gain-layer" class="power-gain-layer"></div>

  <!-- Mine Reset Timer (Top Center) -->
  <div id="mine-reset-timer" class="mine-reset-timer">
    <div id="mine-reset-timer-text" class="mine-reset-timer__text">Mines will reset in: 02:00</div>
    <div id="mining-depth-counter" class="mining-depth-counter">
      <div id="mining-depth-counter-text" class="mining-depth-counter__text">Depth: 0</div>
    </div>
  </div>

  <!-- Mining Target Display (Bottom Center, Above Progress Bar) -->
  <div id="block-health-bar" class="block-health-bar">
    <div id="block-health-bar-name" class="block-health-bar__name">Diamond</div>
    <div class="block-health-bar__container">
      <div class="block-health-bar__outline">
        <div id="block-health-bar-fill" class="block-health-bar__fill"></div>
      </div>
      <div id="block-health-bar-text" class="block-health-bar__text">0/100 HP</div>
    </div>
    <!-- Sell Value (for ores) or Gem Reward (for chests) -->
    <div id="block-reward-display" class="block-health-bar__reward"></div>
  </div>

  <!-- Mining HUD -->
  <div id="mining-hud" class="mining-hud">
    
    <!-- Bottom Middle Right: Damage Display -->
    <div id="damage-display" class="mining-hud__damage"></div>
  </div>

  <!-- Mined Ore Popup Layer -->
  <div id="mined-ore-layer" class="mined-ore-layer"></div>

  <!-- Damage Popup Layer -->
  <div id="damage-popup-layer" class="damage-popup-layer"></div>

  <!-- Merchant Selling UI -->
  <div id="merchant-ui" class="merchant-ui">
    <div class="merchant-ui__header">
      <div class="merchant-ui__title">Ores</div>
      <button id="merchant-ui-close" class="merchant-ui__close">√ó</button>
    </div>
    <div id="merchant-ui-content" class="merchant-ui__content">
      <!-- Ore items will be dynamically added here -->
    </div>
    <div class="merchant-ui__footer">
      <button id="merchant-ui-sell-all" class="merchant-ui__sell-all-button">Sell All</button>
    </div>
  </div>

  <!-- Mine Reset Upgrade UI -->
  <div id="mine-reset-upgrade-ui" class="mine-reset-upgrade-ui">
    <div class="mine-reset-upgrade-ui__header">
      <div class="mine-reset-upgrade-ui__title">Mine Reset Upgrade</div>
      <button id="mine-reset-upgrade-ui-close" class="mine-reset-upgrade-ui__close">√ó</button>
    </div>
    <div class="mine-reset-upgrade-ui__body">
      <div class="mine-reset-upgrade-ui__description">
        Increase your mine reset timer from 2 minutes to 5 minutes!
      </div>
      <div class="mine-reset-upgrade-ui__button-container">
        <button id="mine-reset-upgrade-button" class="mine-reset-upgrade-ui__button">
          <span class="mine-reset-upgrade-ui__button-text">2M</span>
        </button>
      </div>
      <div class="mine-reset-upgrade-ui__status" id="mine-reset-upgrade-status">
        <!-- Status will be updated dynamically -->
      </div>
    </div>
  </div>

  <!-- Gem Trader Upgrades UI -->
  <div id="gem-trader-ui" class="gem-trader-ui">
    <div class="gem-trader-ui__header">
      <button class="gem-trader-ui__help-button">?</button>
      <div class="gem-trader-ui__title">Upgrades</div>
      <button id="gem-trader-ui-close" class="gem-trader-ui__close">√ó</button>
    </div>
    <div id="gem-trader-ui-content" class="gem-trader-ui__content">
      <!-- Upgrade items will be dynamically added here -->
    </div>
  </div>

  <div id="mined-ore-layer" class="mined-ore-layer"></div>

  <!-- Progress Bar (Bottom) -->
  <div id="progress-bar" class="progress-bar">
    <div class="progress-bar__container">
      <div class="progress-bar__outline">
        <div id="progress-bar-fill" class="progress-bar__fill"></div>
        <div id="progress-bar-marker" class="progress-bar__marker"></div>
      </div>
      <div class="progress-bar__markers">
        <span class="progress-bar__marker-label">0</span>
        <span class="progress-bar__marker-label">250</span>
        <span class="progress-bar__marker-label">500</span>
        <span class="progress-bar__marker-label">750</span>
        <span class="progress-bar__marker-label">1000</span>
      </div>
    </div>
  </div>

  <!-- Mining Controls (Visible when in mines) -->
  <div id="mining-controls" class="mining-controls">
    <!-- Mining controls content here if needed -->
  </div>

  <!-- To Surface Button (Always Visible) -->
  <button id="to-surface-button" class="mining-control-button mining-control-button--surface">
    To Surface
  </button>

  <!-- Auto Controls (Right Side) -->
  <div class="auto-controls">
    <!-- Auto Mine Button -->
    <button id="auto-mine-button" class="auto-control-button auto-control-button--mine inactive">
      Auto Mine
    </button>
    <!-- Auto Train Button -->
    <button id="auto-train-button" class="auto-control-button auto-control-button--train">
      Auto Train
    </button>
  </div>
</div>

<style>
  :root {
    font-family: 'Inter', sans-serif;
    color: #fff;
  }

  body {
    margin: 0;
    padding: 0;
  }

  .ui-root {
    position: fixed;
    inset: 0;
    pointer-events: none;
  }

  /* Ensure all interactive UI elements capture clicks and prevent them from reaching the game */
  .ui-root button,
  .ui-root .action-card,
  .ui-root .modal,
  .ui-root .pickaxe-card,
  .ui-root .rebirth-option,
  .ui-root .merchant-ui__item,
  .ui-root .gem-trader-ui__item {
    pointer-events: auto;
  }

  /* Mobile controls (existing boilerplate) */
  .mobile-controls {
    display: none;
  }

  body.mobile .mobile-controls {
    display: flex;
    gap: 14px;
    position: fixed;
    bottom: 40px;
    right: 40px;
    pointer-events: auto;
  }

  .mobile-button {
    background-color: rgba(0, 0, 0, 0.5);
    border-radius: 50%;
    align-items: center;
    justify-content: center;
    display: flex;
    width: 50px;
    height: 50px;
    transition: all 0.15s cubic-bezier(0.4, 0, 0.2, 1);
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
    font-size: 14px;
    font-weight: bold;
    color: rgba(255, 255, 255, 0.8);
    text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
    pointer-events: auto;
  }
  
  .mobile-button img {
    width: 22px;
    height: 22px;
  }

  .mobile-button.active {
    transform: scale(0.92);
    background-color: rgba(0, 0, 0, 0.75);
    box-shadow: 0 1px 4px rgba(0, 0, 0, 0.3);
  }

  /* Stats HUD Container (Middle Right) */
  .stats-hud-container {
    position: fixed;
    top: 50%;
    right: 40px;
    transform: translateY(-50%);
    display: flex;
    flex-direction: column;
    gap: 12px;
    z-index: 1000;
  }

  /* Stat HUD (Blue Box Style) */
  .stat-hud {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 12px 16px;
    min-width: 180px;
    border-radius: 12px;
    border: 3px solid #1a3a5c;
    background: linear-gradient(180deg, rgba(30, 60, 100, 0.95), rgba(20, 40, 70, 0.98));
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
    backdrop-filter: blur(4px);
  }

  .stat-hud__value {
    font-size: 24px;
    font-weight: 700;
    color: #ffd700;
    text-shadow: 
      0 0 8px rgba(255, 215, 0, 0.6),
      0 2px 4px rgba(0, 0, 0, 0.8),
      -1px -1px 0 rgba(0, 0, 0, 0.5),
      1px -1px 0 rgba(0, 0, 0, 0.5),
      -1px 1px 0 rgba(0, 0, 0, 0.5),
      1px 1px 0 rgba(0, 0, 0, 0.5);
    flex: 1;
    text-align: left;
  }

  .stat-hud--money .stat-hud__value {
    color: #ffd700;
  }

  .stat-hud--gems .stat-hud__value {
    color: #4caf50;
  }

  .stat-hud--power .stat-hud__value {
    color: #ff5252;
  }

  .stat-hud--rebirths .stat-hud__value {
    color: #4caf50;
  }

  .stat-hud--wins .stat-hud__value {
    color: #ffd700;
  }

  .stat-hud__icon {
    font-size: 32px;
    width: 40px;
    height: 40px;
    display: flex;
    align-items: center;
    justify-content: center;
    filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.6));
    margin-left: 12px;
  }

  /* Left-side action buttons */
  .left-actions {
    position: fixed;
    left: 32px;
    top: 50%;
    transform: translateY(-50%);
    display: flex;
    flex-direction: column;
    gap: 12px;
    z-index: 1000;
  }

  .action-card {
    width: 72px;
    height: 72px;
    border-radius: 12px;
    border: 3px solid #1a3a5c;
    background: linear-gradient(180deg, rgba(30, 60, 100, 0.95), rgba(20, 40, 70, 0.98));
    box-shadow: 0 4px 18px rgba(0, 0, 0, 0.45);
    display: flex;
    align-items: center;
    justify-content: center;
    position: relative;
    cursor: pointer;
    transition: transform 0.12s ease, box-shadow 0.12s ease;
    pointer-events: auto;
  }

  .action-card:hover {
    transform: translateY(-2px);
    box-shadow: 0 6px 22px rgba(0, 0, 0, 0.55);
  }

  .action-card:active {
    transform: translateY(0);
    box-shadow: 0 3px 12px rgba(0, 0, 0, 0.45);
  }

  .action-card__icon {
    font-size: 32px;
    filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.6));
  }

  .action-card__badge {
    position: absolute;
    top: -6px;
    right: -6px;
    width: 22px;
    height: 22px;
    background: #e53935;
    color: #fff;
    border-radius: 50%;
    border: 2px solid #fff;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 14px;
    font-weight: 800;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.4);
  }

  /* Pets action button accent */
  .action-card--pets {
    border-color: #2d6a4f;
    background: linear-gradient(180deg, rgba(45, 106, 79, 0.95), rgba(26, 77, 56, 0.98));
  }

  /* Egg + Pets UI helpers (use existing modal styles as the base) */
  .egg-actions {
    display: flex;
    gap: 10px;
    flex-wrap: wrap;
    margin-bottom: 14px;
  }

  .egg-results__title {
    font-weight: 800;
    color: rgba(255, 255, 255, 0.9);
    margin-bottom: 8px;
  }

  .egg-results__list {
    display: flex;
    flex-direction: column;
    gap: 8px;
    max-height: 320px;
    overflow: auto;
    padding-right: 4px;
  }

  .egg-result-item {
    background: rgba(0, 0, 0, 0.25);
    border: 2px solid rgba(255, 255, 255, 0.12);
    border-radius: 10px;
    padding: 10px 12px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    color: rgba(255, 255, 255, 0.92);
  }

  .egg-result-item__name {
    font-weight: 800;
  }

  .egg-result-item__mult {
    color: #ffd700;
    font-weight: 900;
  }

  .pets-list {
    display: flex;
    flex-direction: column;
    gap: 10px;
    margin-top: 12px;
    max-height: 420px;
    overflow: auto;
    padding-right: 4px;
  }

  .pet-row {
    background: rgba(0, 0, 0, 0.25);
    border: 2px solid rgba(255, 255, 255, 0.12);
    border-radius: 12px;
    padding: 10px 12px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    color: rgba(255, 255, 255, 0.92);
    gap: 10px;
  }

  .pet-row__left {
    display: flex;
    flex-direction: column;
    gap: 2px;
  }

  .pet-row__name {
    font-weight: 900;
  }

  .pet-row__meta {
    opacity: 0.85;
    font-size: 13px;
  }

  .pet-row__btn {
    border-radius: 10px;
    border: 2px solid rgba(255, 255, 255, 0.18);
    background: rgba(255, 255, 255, 0.06);
    color: #fff;
    font-weight: 900;
    padding: 8px 10px;
    cursor: pointer;
  }

  .pet-row__btn:hover {
    background: rgba(255, 255, 255, 0.12);
  }

  /* Pets grid UI (reference-style) */
  .pets-topbar {
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin-bottom: 10px;
    gap: 12px;
  }

  .pets-topbar__left {
    display: flex;
    gap: 10px;
    align-items: center;
  }

  .pets-pill {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 8px 12px;
    border-radius: 14px;
    border: 3px solid rgba(0, 0, 0, 0.25);
    background: rgba(20, 40, 70, 0.35);
    color: #fff;
    font-weight: 900;
    text-shadow: 0 2px 0 rgba(0, 0, 0, 0.55);
  }

  .pets-pill__icon {
    font-size: 18px;
  }

  .pets-mult {
    display: inline-flex;
    align-items: center;
    gap: 8px;
    padding: 8px 14px;
    border-radius: 16px;
    border: 3px solid rgba(0, 0, 0, 0.25);
    background: rgba(20, 40, 70, 0.35);
    color: #ffcc00;
    font-weight: 900;
    text-shadow: 0 2px 0 rgba(0, 0, 0, 0.55);
    font-size: 20px;
  }

  .pets-content {
    display: flex;
    gap: 16px;
    flex: 1;
    min-height: 0; /* allow children to scroll */
  }

  .pets-grid {
    display: grid;
    /* Big tiles like the reference: auto-fit keeps it responsive without squishing */
    grid-template-columns: repeat(auto-fill, minmax(130px, 1fr));
    gap: 14px;
    padding: 16px;
    border-radius: 18px;
    border: 4px solid rgba(0, 0, 0, 0.25);
    background: rgba(10, 20, 40, 0.18);
    flex: 1;
    overflow: auto;
    min-height: 0;
  }

  .pet-detail {
    width: 360px;
    flex: 0 0 360px;
    border-radius: 18px;
    border: 4px solid rgba(0, 0, 0, 0.25);
    background: rgba(20, 40, 70, 0.35);
    padding: 16px;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 12px;
  }

  .pet-detail__close {
    align-self: flex-start;
    width: 48px;
    height: 48px;
    border-radius: 14px;
    border: 4px solid rgba(0, 0, 0, 0.35);
    background: linear-gradient(180deg, #ef4444, #b91c1c);
    color: #fff;
    font-weight: 1000;
    font-size: 28px;
    cursor: pointer;
  }

  .pet-detail__name {
    font-size: 30px;
    font-weight: 1000;
    color: #fff;
    text-shadow: 0 3px 0 rgba(0, 0, 0, 0.55);
    text-align: center;
  }

  .pet-detail__card {
    width: 240px;
    height: 240px;
    border-radius: 18px;
    border: 5px solid rgba(0, 0, 0, 0.65);
    background: rgba(0, 0, 0, 0.12);
    display: flex;
    align-items: center;
    justify-content: center;
    position: relative;
    overflow: hidden;
  }

  .pet-detail__image {
    width: 82%;
    height: 82%;
    border-radius: 14px;
    background: rgba(0, 0, 0, 0.12);
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 44px;
    color: #fff;
  }

  .pet-detail__img-el {
    width: 100%;
    height: 100%;
    object-fit: contain;
    display: block;
  }

  .pet-detail__mult {
    position: absolute;
    bottom: 10px;
    right: 10px;
    padding: 6px 10px;
    border-radius: 14px;
    background: rgba(0, 0, 0, 0.65);
    color: #fff;
    font-weight: 1000;
    font-size: 26px;
    border: 3px solid rgba(255, 255, 255, 0.35);
    text-shadow: 0 2px 0 rgba(0, 0, 0, 0.55);
  }

  .pet-detail__rarity {
    font-size: 28px;
    font-weight: 1000;
    color: #ff4dff;
    text-shadow: 0 3px 0 rgba(0, 0, 0, 0.55);
  }

  .pet-detail__action {
    width: 100%;
    border-radius: 16px;
    border: 5px solid rgba(0, 0, 0, 0.35);
    padding: 16px 18px;
    font-weight: 1100;
    font-size: 24px;
    cursor: pointer;
    color: #fff;
    text-shadow: 0 2px 0 rgba(0, 0, 0, 0.55);
  }

  .pet-detail__action--equip {
    background: linear-gradient(180deg, #22c55e, #15803d);
  }

  .pet-detail__action--unequip {
    background: linear-gradient(180deg, #ef4444, #b91c1c);
  }

  .pet-tile {
    aspect-ratio: 1 / 1;
    border-radius: 18px;
    border: 5px solid rgba(0, 0, 0, 0.65);
    position: relative;
    cursor: pointer;
    padding: 0;
    overflow: hidden;
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0 8px 18px rgba(0, 0, 0, 0.35);
  }

  .pet-tile--common { background: linear-gradient(180deg, #3b82f6, #1d4ed8); }
  .pet-tile--rare { background: linear-gradient(180deg, #22c55e, #15803d); }
  .pet-tile--epic { background: linear-gradient(180deg, #a855f7, #6d28d9); }
  .pet-tile--legendary { background: linear-gradient(180deg, #facc15, #b45309); }

  .pet-tile--equipped {
    outline: 4px solid rgba(255, 255, 255, 0.85);
    outline-offset: -6px;
  }

  .pet-tile__img {
    width: 84%;
    height: 84%;
    border-radius: 12px;
    background: rgba(0, 0, 0, 0.15);
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 34px;
  }

  .pet-tile__img-el {
    width: 100%;
    height: 100%;
    object-fit: contain;
    image-rendering: auto;
    display: block;
  }

  .pet-tile__mult {
    position: absolute;
    bottom: 8px;
    right: 8px;
    padding: 4px 8px;
    border-radius: 12px;
    background: rgba(0, 0, 0, 0.65);
    color: #fff;
    font-weight: 900;
    font-size: 22px;
    text-shadow: 0 2px 0 rgba(0, 0, 0, 0.55);
    border: 3px solid rgba(255, 255, 255, 0.35);
  }

  .pets-footer {
    display: flex;
    justify-content: center;
    gap: 14px;
    margin-top: 12px;
  }

  .pets-footer__btn {
    border-radius: 14px;
    border: 4px solid rgba(0, 0, 0, 0.35);
    padding: 12px 18px;
    font-weight: 1000;
    font-size: 18px;
    cursor: pointer;
    color: #fff;
    text-shadow: 0 2px 0 rgba(0, 0, 0, 0.55);
    min-width: 240px;
  }

  /* Make Pets modal match the roomy "Frontiers" style panel */
  .pets-modal .pickaxe-modal__container {
    width: min(1180px, 94vw);
    height: min(780px, 86vh);
    max-height: 86vh;
  }

  .pets-modal .pickaxe-modal__header {
    justify-content: center;
    position: relative;
    padding: 18px 18px;
  }

  .pets-modal .pickaxe-modal__title {
    font-size: 44px;
    letter-spacing: 1px;
  }

  .pets-modal .pickaxe-modal__close {
    position: absolute;
    right: 14px;
    top: 14px;
    width: 54px;
    height: 54px;
    border-radius: 14px;
    font-size: 34px;
  }

  .pets-modal .pickaxe-modal__body {
    display: flex;
    flex-direction: column;
    height: calc(100% - 68px);
    padding: 16px 18px 18px;
    gap: 12px;
  }

  .pets-topbar {
    margin-bottom: 0;
  }

  /* Scrollbar similar to the reference */
  .pets-grid::-webkit-scrollbar {
    width: 12px;
  }
  .pets-grid::-webkit-scrollbar-thumb {
    background: rgba(255, 255, 255, 0.25);
    border-radius: 10px;
    border: 3px solid rgba(0, 0, 0, 0.25);
  }
  .pets-grid::-webkit-scrollbar-track {
    background: rgba(0, 0, 0, 0.15);
    border-radius: 10px;
  }

  .pets-footer__btn--green {
    background: linear-gradient(180deg, #22c55e, #15803d);
  }

  .pets-footer__btn--red {
    background: linear-gradient(180deg, #ef4444, #b91c1c);
  }

  .pets-footer__icon {
    width: 72px;
    height: 56px;
    border-radius: 14px;
    border: 4px solid rgba(0, 0, 0, 0.35);
    background: rgba(20, 40, 70, 0.35);
    cursor: pointer;
    font-size: 26px;
    color: #fff;
    text-shadow: 0 2px 0 rgba(0, 0, 0, 0.55);
  }

  .pets-delete-bar {
    position: absolute;
    left: 50%;
    bottom: 18px;
    transform: translateX(-50%);
    width: min(520px, 92%);
    border-radius: 18px;
    border: 4px solid rgba(0, 0, 0, 0.35);
    background: rgba(20, 40, 70, 0.55);
    padding: 14px;
    display: flex;
    flex-direction: column;
    gap: 12px;
    z-index: 5;
  }

  /* Ensure HTML `hidden` attribute always wins (prevents showing until delete mode). */
  .pets-delete-bar[hidden] {
    display: none !important;
  }

  .pets-delete-bar__text {
    font-size: 24px;
    font-weight: 1100;
    color: #fff;
    text-shadow: 0 3px 0 rgba(0, 0, 0, 0.55);
    text-align: center;
  }

  .pets-delete-bar__actions {
    display: flex;
    gap: 12px;
    justify-content: center;
  }

  .pets-delete-bar__btn {
    border-radius: 16px;
    border: 5px solid rgba(0, 0, 0, 0.35);
    padding: 14px 18px;
    font-weight: 1100;
    font-size: 20px;
    cursor: pointer;
    color: #fff;
    text-shadow: 0 2px 0 rgba(0, 0, 0, 0.55);
    min-width: 170px;
  }

  .pets-delete-bar__btn--green {
    background: linear-gradient(180deg, #22c55e, #15803d);
  }

  .pets-delete-bar__btn--red {
    background: linear-gradient(180deg, #ef4444, #b91c1c);
  }

  .pets-delete-bar__btn:disabled {
    opacity: 0.55;
    cursor: not-allowed;
    filter: grayscale(0.2);
  }

  .pet-tile__delete-overlay {
    position: absolute;
    inset: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 80px;
    font-weight: 1100;
    color: rgba(255, 0, 0, 0.9);
    text-shadow:
      0 6px 0 rgba(0, 0, 0, 0.55),
      -3px -3px 0 rgba(0, 0, 0, 0.55),
      3px -3px 0 rgba(0, 0, 0, 0.55),
      -3px 3px 0 rgba(0, 0, 0, 0.55),
      3px 3px 0 rgba(0, 0, 0, 0.55);
    pointer-events: none;
  }

  /* Modals */
  .modal {
    position: fixed;
    inset: 0;
    display: none;
    align-items: center;
    justify-content: center;
    z-index: 1200;
    background: rgba(0, 0, 0, 0.55);
    pointer-events: auto;
  }

  .modal.visible {
    display: flex;
  }

  .modal__body {
    padding: 16px;
  }

  .modal__header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 14px 16px;
    border-bottom: 3px solid #1a3a5c;
  }

  .modal__title {
    font-size: 24px;
    font-weight: 800;
    color: #fff;
    text-shadow: 0 2px 6px rgba(0, 0, 0, 0.5);
  }

  .modal__close {
    width: 36px;
    height: 36px;
    border-radius: 10px;
    border: 3px solid #c0392b;
    background: linear-gradient(180deg, #e74c3c, #c0392b);
    color: #fff;
    font-size: 20px;
    font-weight: 800;
    cursor: pointer;
    box-shadow: 0 3px 12px rgba(0, 0, 0, 0.4);
  }

  .rebirth-modal__container {
    width: 700px;
    max-width: 95vw;
    max-height: 85vh;
    background: rgba(21, 26, 60, 0.98);
    border: 3px solid #4a90e2;
    border-radius: 12px;
    display: flex;
    flex-direction: column;
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.6);
    overflow: hidden;
    margin: auto;
  }

  .rebirth-modal__header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 20px;
    border-bottom: 2px solid #4a90e2;
    background: rgba(21, 26, 60, 0.98);
  }

  .rebirth-modal__title {
    font-size: 24px;
    font-weight: 700;
    color: #fff;
    text-transform: uppercase;
    letter-spacing: 1px;
  }

  .rebirth-modal__close {
    width: 32px;
    height: 32px;
    background: rgba(244, 67, 54, 0.8);
    border: 2px solid #f44336;
    border-radius: 6px;
    color: #fff;
    font-size: 20px;
    font-weight: 700;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.2s ease;
  }

  .rebirth-modal__close:hover {
    background: rgba(244, 67, 54, 1);
    transform: scale(1.1);
  }

  .pickaxe-modal__container {
    width: 1800px;
    max-width: 95vw;
    max-height: 85vh;
    background: rgba(21, 26, 60, 0.98);
    border: 3px solid #4a90e2;
    border-radius: 12px;
    display: flex;
    flex-direction: column;
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.6);
    overflow: hidden;
    margin: auto; /* Ensure it's centered */
  }

  .pickaxe-modal__header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 20px;
    border-bottom: 2px solid #4a90e2;
    background: rgba(21, 26, 60, 0.98);
  }

  .pickaxe-modal__title {
    font-size: 24px;
    font-weight: 700;
    color: #fff;
    text-transform: uppercase;
    letter-spacing: 1px;
  }

  .pickaxe-modal__close {
    width: 32px;
    height: 32px;
    background: rgba(244, 67, 54, 0.8);
    border: 2px solid #f44336;
    border-radius: 6px;
    color: #fff;
    font-size: 20px;
    font-weight: 700;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.2s ease;
  }

  .pickaxe-modal__close:hover {
    background: rgba(244, 67, 54, 1);
    transform: scale(1.1);
  }

  .pickaxe-modal__body {
    display: flex;
    flex: 1;
    overflow: hidden;
  }

  .pickaxe-modal__left-panel {
    width: 300px;
    min-width: 300px;
    padding: 20px;
    border-right: 2px solid #4a90e2;
    background: rgba(15, 20, 50, 0.95);
    display: flex;
    flex-direction: column;
  }

  .pickaxe-modal__right-panel {
    flex: 1;
    padding: 20px;
    overflow-y: auto;
    overflow-x: hidden;
    background: rgba(21, 26, 60, 0.98);
  }

  .rebirth-modal__body {
    padding: 20px;
    display: flex;
    flex-direction: column;
    gap: 16px;
    background: rgba(21, 26, 60, 0.98);
    overflow-y: auto;
    max-height: calc(85vh - 80px);
  }

  .rebirth-modal__instruction {
    font-size: 18px;
    font-weight: 700;
    color: #ffd700;
    text-align: center;
    text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
  }

  .rebirth-modal__explanation {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
    padding: 12px;
    background: rgba(0, 0, 0, 0.3);
    border-radius: 8px;
    border: 2px solid #1a3a5c;
  }

  .rebirth-icon {
    font-size: 24px;
  }

  .rebirth-text {
    font-size: 18px;
    font-weight: 700;
    color: #fff;
  }

  .rebirth-equals {
    font-size: 18px;
    font-weight: 700;
    color: #fff;
  }

  .power-icon {
    font-size: 24px;
  }

  .power-text {
    font-size: 18px;
    font-weight: 700;
    color: #ff5252;
  }

  .rebirth-options {
    display: flex;
    flex-direction: column;
    gap: 12px;
  }

  .rebirth-option {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 16px 20px;
    background: rgba(30, 40, 80, 0.8);
    border: 2px solid #1a3a5c;
    border-radius: 12px;
    transition: all 0.2s ease;
  }

  .rebirth-option:hover:not(.unavailable) {
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
  }

  .rebirth-option--max {
    border: 3px solid;
    border-image: linear-gradient(90deg, #ff0000, #ff8800, #ffd700, #4caf50, #2196f3, #9c27b0) 1;
    background: rgba(30, 40, 80, 0.9);
  }

  .rebirth-option.unavailable {
    opacity: 0.5;
    cursor: not-allowed;
  }

  .rebirth-option__info {
    display: flex;
    flex-direction: column;
    gap: 8px;
    flex: 1;
  }

  .rebirth-option__title {
    font-size: 18px;
    font-weight: 700;
    color: #4caf50;
  }

  .rebirth-option__cost {
    font-size: 16px;
    font-weight: 700;
    color: #ff5252;
  }

  .rebirth-option__action {
    margin-left: 20px;
  }

  .rebirth-button {
    padding: 12px 24px;
    border-radius: 8px;
    border: 2px solid #4caf50;
    background: linear-gradient(180deg, #66bb6a, #2e7d32);
    color: #fff;
    font-size: 16px;
    font-weight: 700;
    cursor: pointer;
    transition: all 0.2s ease;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
  }

  .rebirth-button:hover:not(.disabled) {
    transform: scale(1.05);
    box-shadow: 0 6px 16px rgba(76, 175, 80, 0.5);
  }

  .rebirth-button.disabled {
    opacity: 0.5;
    cursor: not-allowed;
    filter: grayscale(0.5);
  }

  .rebirth-button--max {
    padding: 12px 24px;
    border-radius: 8px;
    border: 3px solid #000;
    background: linear-gradient(180deg, #ffd700, #ffaa00);
    color: #000;
    font-size: 16px;
    font-weight: 800;
    cursor: pointer;
    transition: all 0.2s ease;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
  }

  .rebirth-button--max:hover:not(.disabled) {
    transform: scale(1.05);
    box-shadow: 0 6px 16px rgba(255, 215, 0, 0.6);
  }

  .rebirth-button--max.disabled {
    opacity: 0.5;
    cursor: not-allowed;
    filter: grayscale(0.5);
  }

  .pickaxe-details {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 16px;
    padding: 20px;
    background: rgba(30, 40, 80, 0.8);
    border: 2px solid #4a90e2;
    border-radius: 12px;
  }

  .pickaxe-details__icon {
    width: 120px;
    height: 120px;
    border-radius: 12px;
    border: 3px solid #1a3a5c;
    background: linear-gradient(180deg, rgba(30, 60, 100, 0.95), rgba(20, 40, 70, 0.95));
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 64px;
    box-shadow: inset 0 0 12px rgba(0, 0, 0, 0.4);
  }

  .pickaxe-details__name {
    font-size: 22px;
    font-weight: 700;
    color: #fff;
    text-align: center;
  }

  .pickaxe-details__badge {
    margin-top: 8px;
    padding: 6px 16px;
    background: linear-gradient(180deg, rgba(76, 175, 80, 0.9), rgba(46, 125, 50, 0.95));
    border: 2px solid #4caf50;
    border-radius: 8px;
    color: #fff;
    font-size: 14px;
    font-weight: 700;
    text-transform: uppercase;
    letter-spacing: 1px;
  }

  .pickaxe-details__stats {
    display: flex;
    flex-direction: column;
    gap: 8px;
    margin-top: 8px;
  }

  .pickaxe-stat {
    font-size: 14px;
    font-weight: 700;
    padding: 4px 8px;
    border-radius: 6px;
    background: rgba(0, 0, 0, 0.3);
  }

  .pickaxe-stat--power {
    color: #ff5252;
  }

  .pickaxe-stat--luck {
    color: #4caf50;
  }

  .pickaxe-stat--speed {
    color: #87ceeb;
  }

  .pickaxe-stat--damage {
    color: #ffd700;
  }

  .pickaxe-stat--sell {
    color: #ffd700;
  }

  .pickaxe-details__cost {
    font-size: 16px;
    color: #e0f2ff;
    margin-top: 4px;
  }

  .pickaxe-details__action-button {
    width: 100%;
    padding: 12px 20px;
    margin-top: 16px;
    border-radius: 8px;
    border: 2px solid #4caf50;
    background: linear-gradient(180deg, #66bb6a, #2e7d32);
    color: #fff;
    font-size: 16px;
    font-weight: 700;
    cursor: pointer;
    transition: all 0.2s ease;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }

  .pickaxe-details__action-button:hover:not(.disabled) {
    transform: scale(1.05);
    box-shadow: 0 6px 16px rgba(76, 175, 80, 0.5);
  }

  .pickaxe-details__action-button.disabled {
    opacity: 0.5;
    cursor: not-allowed;
    filter: grayscale(0.5);
  }

  .pickaxe-actions {
    margin: 12px 0;
    display: flex;
    justify-content: flex-start;
  }

  .primary-button {
    padding: 12px 20px;
    border-radius: 12px;
    border: 3px solid #4caf50;
    background: linear-gradient(180deg, #66bb6a, #2e7d32);
    color: #fff;
    font-size: 16px;
    font-weight: 800;
    cursor: pointer;
    box-shadow: 0 4px 14px rgba(0, 0, 0, 0.45);
  }

  .primary-button.disabled {
    opacity: 0.6;
    cursor: not-allowed;
    filter: grayscale(0.2);
  }

  .pickaxe-grid {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 20px;
    width: 100%;
    overflow-x: hidden;
    min-width: 0; /* Prevent grid from overflowing */
    padding-right: 8px; /* Add padding for scrollbar */
  }

  .pickaxe-card {
    position: relative;
    border-radius: 12px;
    border: 3px solid #1a3a5c;
    background: linear-gradient(180deg, rgba(30, 60, 100, 0.95), rgba(20, 40, 70, 0.98));
    padding: 16px;
    color: #fff;
    cursor: pointer;
    box-shadow: 0 3px 12px rgba(0, 0, 0, 0.4);
    transition: transform 0.12s ease, box-shadow 0.12s ease;
    display: flex;
    flex-direction: column;
    align-items: center;
    text-align: center;
    min-height: 140px;
    min-width: 0; /* Prevent cards from overflowing grid */
    max-width: 100%; /* Ensure cards don't exceed grid cell */
    justify-content: space-between;
    box-sizing: border-box; /* Include padding and border in width calculation */
  }

  .pickaxe-card:hover {
    transform: translateY(-2px);
    box-shadow: 0 5px 18px rgba(0, 0, 0, 0.45);
  }

  .pickaxe-card.selected {
    border-color: #ffd700;
    box-shadow: 0 0 0 2px #ffd700, 0 5px 18px rgba(0, 0, 0, 0.45);
  }

  .pickaxe-card__name {
    font-size: 14px;
    font-weight: 700;
    margin-top: 8px;
    word-wrap: break-word;
    overflow-wrap: break-word;
    hyphens: auto;
    width: 100%;
  }

  .pickaxe-card__icon {
    font-size: 48px;
    margin: 4px 0;
  }

  .pickaxe-card__cost {
    color: #ffd700;
    font-weight: 700;
  }

  .pickaxe-card__lock {
    position: absolute;
    inset: 0;
    background: rgba(0, 0, 0, 0.55);
    border-radius: 10px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 28px;
    color: #fff;
  }

  .pickaxe-card__checkmark {
    position: absolute;
    top: 8px;
    right: 8px;
    width: 24px;
    height: 24px;
    background: #4caf50;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    color: #fff;
    font-weight: 800;
    font-size: 16px;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.4);
  }

  .pickaxe-card__buy-button {
    width: 100%;
    padding: 8px 12px;
    margin-top: 8px;
    border-radius: 8px;
    border: 2px solid #4caf50;
    background: linear-gradient(180deg, #66bb6a, #2e7d32);
    color: #fff;
    font-size: 14px;
    font-weight: 700;
    cursor: pointer;
    transition: transform 0.1s ease;
  }

  .pickaxe-card__buy-button:hover {
    transform: scale(1.05);
  }

  .pickaxe-card.purchased {
    /* Normal appearance for purchased pickaxes */
    opacity: 1;
    cursor: pointer;
  }

  .pickaxe-card.equipped {
    border-color: #4caf50;
    box-shadow: 0 0 0 2px #4caf50, 0 5px 18px rgba(0, 0, 0, 0.45);
    opacity: 1;
  }

  .pickaxe-card.next-tier {
    /* Greyed out but purchasable (next tier) */
    opacity: 0.5;
    filter: grayscale(0.3);
    cursor: pointer;
  }

  .pickaxe-card.locked {
    /* Greyed out with lock (future tiers) */
    opacity: 0.4;
    filter: grayscale(0.6);
    cursor: not-allowed;
  }

  /* Rebirth UI */
  .rebirth-summary {
    display: flex;
    flex-direction: column;
    gap: 6px;
    padding: 10px 12px;
    border: 2px solid #1a3a5c;
    border-radius: 10px;
    background: rgba(255, 255, 255, 0.05);
    margin-bottom: 12px;
  }

  .rebirth-summary__row {
    display: flex;
    justify-content: space-between;
    font-size: 16px;
    color: #e0f2ff;
  }

  .rebirth-options {
    display: flex;
    flex-direction: column;
    gap: 10px;
  }

  .rebirth-card {
    border-radius: 12px;
    border: 3px solid #1a3a5c;
    background: linear-gradient(180deg, rgba(30, 60, 100, 0.95), rgba(20, 40, 70, 0.98));
    padding: 12px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    color: #fff;
    box-shadow: 0 3px 12px rgba(0, 0, 0, 0.4);
  }

  .rebirth-card__title {
    font-size: 18px;
    font-weight: 800;
  }

  .rebirth-card__cost {
    color: #ff5252;
    font-weight: 800;
    margin-top: 4px;
  }

  .rebirth-card__bonus {
    color: #4caf50;
    font-weight: 700;
  }

  .rebirth-card__action {
    margin-left: 12px;
  }

  /* Power gain floating text */
  .power-gain-layer {
    position: fixed;
    inset: 0;
    pointer-events: none;
    overflow: hidden;
  }

  .power-gain {
    position: absolute;
    display: flex;
    align-items: center;
    gap: 8px;
    color: #ff5252;
    font-size: 34px;
    font-weight: 800;
    text-shadow: 0 4px 18px rgba(0, 0, 0, 0.4);
    opacity: 0;
    transform: translate(-50%, -50%) scale(0.8);
    transition: transform 0.6s cubic-bezier(0.22, 1, 0.36, 1), opacity 0.6s, filter 0.6s;
    pointer-events: none;
    z-index: 10000;
    white-space: nowrap;
  }

  .power-gain__icon {
    font-size: 32px;
    filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.5));
  }

  .power-gain__text {
    color: #ff5252;
    text-shadow: 
      0 0 10px rgba(255, 82, 82, 0.8),
      0 2px 4px rgba(0, 0, 0, 0.8),
      -1px -1px 0 rgba(0, 0, 0, 0.5),
      1px -1px 0 rgba(0, 0, 0, 0.5),
      -1px 1px 0 rgba(0, 0, 0, 0.5),
      1px 1px 0 rgba(0, 0, 0, 0.5);
  }

  .power-gain.active {
    opacity: 1;
    transform: translate(-50%, -50%) scale(1.05);
    filter: drop-shadow(0 0 12px rgba(255, 99, 132, 0.9));
  }

  /* Training prompt */
  .training-prompt {
    position: fixed;
    left: 50%;
    bottom: 120px;
    transform: translate(-50%, 20px);
    display: flex;
    align-items: center;
    gap: 14px;
    padding: 14px 24px;
    border-radius: 18px;
    border: 3px solid rgba(255, 255, 255, 0.9);
    background: rgba(21, 26, 60, 0.92);
    box-shadow: 0 20px 40px rgba(0, 0, 0, 0.55);
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.2s ease, transform 0.2s ease;
  }

  .training-prompt.visible {
    opacity: 1;
    transform: translate(-50%, 0);
  }

  .training-prompt.locked {
    border-color: rgba(255, 255, 255, 0.4);
    background: rgba(50, 50, 70, 0.8);
  }

  .training-prompt__key {
    width: 48px;
    height: 48px;
    border-radius: 14px;
    background: rgba(0, 0, 0, 0.4);
    border: 2px solid rgba(255, 255, 255, 0.5);
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 20px;
    font-weight: 700;
  }

  .training-prompt__title {
    font-size: 16px;
    font-weight: 700;
    text-transform: uppercase;
    letter-spacing: 1px;
  }

  .training-prompt__subtitle {
    font-size: 13px;
    opacity: 0.8;
  }

  /* Scene UI prompt */
  .scene-training-prompt {
    font-family: 'Inter', sans-serif;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 4px;
    padding: 12px 20px;
    border-radius: 16px;
    border: 3px solid rgba(255, 255, 255, 0.9);
    background: rgba(23, 27, 61, 0.95);
    box-shadow: 0 12px 28px rgba(0, 0, 0, 0.55);
    color: #fff;
    text-transform: uppercase;
    opacity: 1; /* Start visible */
    transition: opacity 0.15s ease;
    pointer-events: none;
    transform: scale(0.75); /* Make it 0.75x smaller */
    min-width: 180px;
  }

  .scene-training-prompt:not(.visible) {
    opacity: 0;
  }

  .scene-training-prompt.visible {
    opacity: 1;
  }

  .scene-training-prompt.locked {
    border-color: rgba(255, 255, 255, 0.4);
    background: rgba(60, 60, 80, 0.9);
  }

  .scene-training-prompt__icon {
    font-size: 32px;
    line-height: 1;
    margin-bottom: 4px;
  }

  .scene-training-prompt__copy {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 2px;
    width: 100%;
  }

  .scene-training-prompt__requirement {
    font-size: 18px;
    font-weight: 800;
    color: #fff;
    text-shadow: 
      0 0 10px rgba(255, 255, 255, 0.8),
      0 2px 4px rgba(0, 0, 0, 0.8),
      -1px -1px 0 rgba(0, 0, 0, 0.5),
      1px -1px 0 rgba(0, 0, 0, 0.5),
      -1px 1px 0 rgba(0, 0, 0, 0.5),
      1px 1px 0 rgba(0, 0, 0, 0.5);
    letter-spacing: 0.5px;
  }

  .scene-training-prompt__or {
    font-size: 14px;
    font-weight: 700;
    color: #4a9eff;
    text-shadow: 
      0 0 8px rgba(74, 158, 255, 0.6),
      0 2px 4px rgba(0, 0, 0, 0.8);
    letter-spacing: 1px;
  }

  .scene-training-prompt__rebirth {
    font-size: 18px;
    font-weight: 800;
    color: #4caf50;
    text-shadow: 
      0 0 10px rgba(76, 175, 80, 0.8),
      0 2px 4px rgba(0, 0, 0, 0.8),
      -1px -1px 0 rgba(0, 0, 0, 0.5),
      1px -1px 0 rgba(0, 0, 0, 0.5),
      -1px 1px 0 rgba(0, 0, 0, 0.5),
      1px 1px 0 rgba(0, 0, 0, 0.5);
    letter-spacing: 0.5px;
  }

  .scene-training-prompt__power-gain {
    font-size: 18px;
    font-weight: 800;
    color: #ff5252;
    text-shadow: 
      0 0 10px rgba(255, 82, 82, 0.8),
      0 2px 4px rgba(0, 0, 0, 0.8),
      -1px -1px 0 rgba(0, 0, 0, 0.5),
      1px -1px 0 rgba(0, 0, 0, 0.5),
      -1px 1px 0 rgba(0, 0, 0, 0.5),
      1px 1px 0 rgba(0, 0, 0, 0.5);
    letter-spacing: 0.5px;
    margin-top: 2px;
  }

  /* Scene UI: Egg labels (name + cost, like the reference image) */
  .scene-egg-prompt {
    font-family: 'Inter', sans-serif;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 2px;
    padding: 4px 8px;
    border-radius: 14px;
    background: rgba(0, 0, 0, 0); /* floating text only */
    color: #fff;
    opacity: 1;
    transition: opacity 0.15s ease;
    pointer-events: none;
    transform: scale(0.9);
    min-width: 140px;
  }

  .scene-egg-prompt:not(.visible) {
    opacity: 0;
  }

  .scene-egg-prompt__icon {
    display: none; /* egg model exists in-world; label should be text-only */
  }

  .scene-egg-prompt__copy {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 2px;
  }

  .scene-egg-prompt__title {
    font-size: 28px;
    font-weight: 900;
    color: #ffffff;
    text-shadow:
      0 3px 0 rgba(0, 0, 0, 0.65),
      -2px -2px 0 rgba(0, 0, 0, 0.65),
      2px -2px 0 rgba(0, 0, 0, 0.65),
      -2px 2px 0 rgba(0, 0, 0, 0.65),
      2px 2px 0 rgba(0, 0, 0, 0.65);
  }

  .scene-egg-prompt__cost {
    font-size: 20px;
    font-weight: 900;
    color: #ffcc00;
    text-shadow:
      0 3px 0 rgba(0, 0, 0, 0.65),
      -2px -2px 0 rgba(0, 0, 0, 0.65),
      2px -2px 0 rgba(0, 0, 0, 0.65),
      -2px 2px 0 rgba(0, 0, 0, 0.65),
      2px 2px 0 rgba(0, 0, 0, 0.65);
  }


  /* Mining HUD */
  .mining-hud {
    position: fixed;
    bottom: 0;
    left: 0;
    right: 0;
    pointer-events: none;
    opacity: 0;
    transition: opacity 0.3s ease;
  }

  .mining-hud.visible {
    opacity: 1;
  }

  /* Old current ore display removed - now using mining target display */

  /* Bottom Middle Right: Damage Display */
  .mining-hud__damage {
    position: fixed;
    right: 40px;
    bottom: 200px;
    padding: 8px 16px;
    border-radius: 10px;
    background: rgba(185, 0, 0, 0.8);
    border: 2px solid rgba(255, 0, 0, 0.5);
    color: #fff;
    font-size: 20px;
    font-weight: 800;
    text-shadow: 
      0 0 10px rgba(255, 0, 0, 0.8),
      0 2px 4px rgba(0, 0, 0, 0.8),
      -1px -1px 0 rgba(0, 0, 0, 0.5),
      1px -1px 0 rgba(0, 0, 0, 0.5),
      -1px 1px 0 rgba(0, 0, 0, 0.5),
      1px 1px 0 rgba(0, 0, 0, 0.5);
    opacity: 0;
    transition: opacity 0.3s ease;
    pointer-events: none;
  }

  .mining-hud__damage.visible {
    opacity: 1;
  }

  /* Mined Ore Popup Layer */
  .mined-ore-layer {
    position: fixed;
    inset: 0;
    pointer-events: none;
    overflow: hidden;
  }

  /* Mined Ore Floating Popup - Positioned above block health bar */
  .mined-ore-popup {
    position: fixed;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 8px 16px;
    color: #fff;
    font-size: 22px;
    font-weight: 700;
    text-transform: uppercase;
    letter-spacing: 2px;
    text-shadow: 
      -2px -2px 0 #000,
      2px -2px 0 #000,
      -2px 2px 0 #000,
      2px 2px 0 #000,
      0 0 10px rgba(0, 0, 0, 0.8);
    opacity: 0;
    pointer-events: none;
    z-index: 1001;
  }

  /* Float up animation */
  .mined-ore-popup.active {
    animation: orePopupFloatUp 0.4s ease-out forwards;
  }

  /* Fade out animation */
  .mined-ore-popup.fade-out {
    animation: orePopupFadeOut 0.3s ease-out forwards;
  }

  @keyframes orePopupFloatUp {
    0% {
      opacity: 0;
      transform: translateX(-50%) translateY(30px) scale(0.8);
    }
    50% {
      opacity: 1;
      transform: translateX(-50%) translateY(-10px) scale(1.1);
    }
    100% {
      opacity: 1;
      transform: translateX(-50%) translateY(-20px) scale(1);
    }
  }

  @keyframes orePopupFadeOut {
    0% {
      opacity: 1;
      transform: translateX(-50%) translateY(-20px);
    }
    100% {
      opacity: 0;
      transform: translateX(-50%) translateY(-40px);
    }
  }

  .mined-ore-popup__text {
    /* Color is set dynamically based on ore type */
    font-weight: 800;
  }

  /* Damage Popup Layer */
  .damage-popup-layer {
    position: fixed;
    inset: 0;
    pointer-events: none;
    overflow: hidden;
    z-index: 1000;
  }

  /* Damage Popup (To the right of HP bar) */
  .damage-popup {
    position: fixed;
    display: flex;
    align-items: center;
    justify-content: flex-start;
    pointer-events: none;
    opacity: 0;
    transform: translateY(0) scale(0.9);
    transition: opacity 0.4s ease, transform 1.5s ease-out;
  }

  .damage-popup.active {
    opacity: 1;
    transform: translateY(-80px) scale(1);
  }

  .damage-popup__text {
    color: #ff0000;
    font-size: 32px;
    font-weight: 800;
    font-family: 'Arial', sans-serif;
    text-shadow: 
      -2px -2px 0 #000,
      2px -2px 0 #000,
      -2px 2px 0 #000,
      2px 2px 0 #000,
      0 0 10px rgba(0, 0, 0, 0.8),
      0 4px 8px rgba(0, 0, 0, 0.6);
    letter-spacing: 1px;
    white-space: nowrap;
  }

  /* Mine Reset Timer (Top Center) */
  .mine-reset-timer {
    position: fixed;
    top: 80px;
    left: 50%;
    transform: translateX(-50%);
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.3s ease;
    z-index: 1001;
  }

  .mine-reset-timer.visible {
    opacity: 1;
  }

  .mine-reset-timer__text {
    padding: 12px 24px;
    border-radius: 12px;
    background: rgba(0, 0, 0, 0.85);
    border: 3px solid rgba(255, 255, 255, 0.9);
    color: #fff;
    font-size: 24px;
    font-weight: 800;
    text-transform: uppercase;
    letter-spacing: 2px;
    text-shadow: 
      -2px -2px 0 #000,
      2px -2px 0 #000,
      -2px 2px 0 #000,
      2px 2px 0 #000,
      0 0 10px rgba(0, 0, 0, 0.8);
    white-space: nowrap;
  }

  /* Mining Depth Counter */
  .mining-depth-counter {
    margin-top: 8px;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.3s ease;
  }

  .mine-reset-timer.visible .mining-depth-counter {
    opacity: 1;
  }

  .mining-depth-counter__text {
    padding: 8px 20px;
    border-radius: 10px;
    background: rgba(0, 0, 0, 0.85);
    border: 3px solid rgba(255, 255, 255, 0.9);
    color: #fff;
    font-size: 20px;
    font-weight: 800;
    text-transform: uppercase;
    letter-spacing: 1.5px;
    text-shadow: 
      -2px -2px 0 #000,
      2px -2px 0 #000,
      -2px 2px 0 #000,
      2px 2px 0 #000,
      0 0 10px rgba(0, 0, 0, 0.8);
    text-align: center;
    white-space: nowrap;
  }

  /* Block Health Bar (Bottom Center) */
  .block-health-bar {
    position: fixed;
    bottom: 120px;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 8px;
    opacity: 0;
    pointer-events: none;
    /* Removed transition to prevent UI disappearing when switching ores quickly */
    z-index: 1000;
  }

  .block-health-bar.visible {
    opacity: 1;
    /* Instant show - no transition */
  }

  .block-health-bar__name {
    font-size: 24px;
    font-weight: 700;
    text-transform: uppercase;
    letter-spacing: 2px;
    color: #fff;
    text-shadow: 
      -2px -2px 0 #000,
      2px -2px 0 #000,
      -2px 2px 0 #000,
      2px 2px 0 #000,
      0 0 10px rgba(0, 0, 0, 0.8);
  }

  .block-health-bar__container {
    position: relative;
    width: 300px;
  }

  .block-health-bar__outline {
    width: 100%;
    height: 32px;
    border: 3px solid #1a3a5c;
    background: #0d2440;
    border-radius: 6px;
    position: relative;
    overflow: hidden;
  }

  .block-health-bar__fill {
    position: absolute;
    top: 0;
    left: 0;
    height: 100%;
    background: linear-gradient(90deg, #4caf50 0%, #66bb6a 100%);
    transition: width 0.3s ease;
    border-radius: 3px;
  }

  .block-health-bar__text {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 14px;
    font-weight: 700;
    color: #fff;
    text-shadow: 
      -1px -1px 0 #000,
      1px -1px 0 #000,
      -1px 1px 0 #000,
      1px 1px 0 #000,
      0 0 8px rgba(0, 0, 0, 0.8);
    white-space: nowrap;
    pointer-events: none;
    z-index: 1;
  }

  .block-health-bar__reward {
    display: none;
    align-items: center;
    gap: 6px;
    font-size: 18px;
    font-weight: 700;
    margin-top: 4px;
    text-shadow: 
      -1px -1px 0 #000,
      1px -1px 0 #000,
      -1px 1px 0 #000,
      1px 1px 0 #000,
      0 0 8px rgba(0, 0, 0, 0.8);
  }

  /* Progress Bar (Bottom) */
  .progress-bar {
    position: fixed;
    bottom: 0;
    left: 0;
    right: 0;
    padding: 20px 40px;
    pointer-events: none;
    z-index: 1000;
  }

  .progress-bar__container {
    max-width: 1200px;
    margin: 0 auto;
  }

  .progress-bar__outline {
    position: relative;
    width: 100%;
    height: 40px;
    border: 4px solid #1a3a5c;
    background: #0d2440;
    border-radius: 8px;
    overflow: visible;
  }

  .progress-bar__fill {
    position: absolute;
    top: 0;
    left: 0;
    height: 100%;
    background: linear-gradient(90deg, #4caf50 0%, #66bb6a 50%, #81c784 100%);
    border-radius: 4px;
    transition: width 0.3s ease;
    width: 0%;
  }

  .progress-bar__marker {
    position: absolute;
    top: -8px;
    width: 24px;
    height: 56px;
    background: radial-gradient(circle, #fff 0%, #ffd166 50%, #ff4b5c 100%);
    border: 3px solid #1a3a5c;
    border-radius: 12px;
    transform: translateX(-50%);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
    transition: left 0.3s ease;
    left: 0%;
  }

  .progress-bar__markers {
    display: flex;
    justify-content: space-between;
    margin-top: 8px;
    padding: 0 8px;
  }

  .progress-bar__marker-label {
    font-size: 14px;
    font-weight: 700;
    color: #fff;
    text-shadow: 
      -1px -1px 0 #000,
      1px -1px 0 #000,
      -1px 1px 0 #000,
      1px 1px 0 #000;
  }

  /* Mining Controls */
  .mining-controls {
    position: fixed;
    bottom: 80px;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    gap: 16px;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.3s ease;
    z-index: 900;
  }

  .mining-controls.visible {
    opacity: 1;
    pointer-events: auto;
  }

  /* To Surface button is always visible, positioned at top of HUD */
  #to-surface-button {
    position: fixed;
    top: 20px;
    left: 50%;
    transform: translateX(-50%);
    opacity: 1 !important;
    pointer-events: auto !important;
    z-index: 901;
  }

  .mining-control-button {
    padding: 12px 24px;
    border-radius: 12px;
    border: 3px solid rgba(255, 255, 255, 0.9);
    background: rgba(21, 26, 60, 0.92);
    color: #fff;
    font-size: 16px;
    font-weight: 700;
    text-transform: uppercase;
    letter-spacing: 1px;
    cursor: pointer;
    pointer-events: auto;
    transition: all 0.2s ease;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
  }

  .mining-control-button:hover {
    transform: scale(1.05);
    box-shadow: 0 6px 16px rgba(0, 0, 0, 0.5);
  }

  .mining-control-button:active {
    transform: scale(0.98);
  }

  .mining-control-button--surface {
    background: linear-gradient(180deg, rgba(76, 175, 80, 0.9), rgba(46, 125, 50, 0.95));
    border-color: #4caf50;
  }

  /* Auto Controls (Right Side) */
  .auto-controls {
    position: fixed;
    right: 40px;
    bottom: 200px;
    display: flex;
    flex-direction: column;
    gap: 12px;
    pointer-events: auto;
    z-index: 900;
  }

  .auto-control-button {
    padding: 14px 20px;
    border-radius: 12px;
    border: 3px solid rgba(255, 255, 255, 0.9);
    background: rgba(21, 26, 60, 0.92);
    color: #fff;
    font-size: 16px;
    font-weight: 700;
    text-transform: uppercase;
    letter-spacing: 1px;
    cursor: pointer;
    transition: all 0.2s ease;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
    min-width: 140px;
  }

  .auto-control-button:hover {
    transform: scale(1.05);
    box-shadow: 0 6px 16px rgba(0, 0, 0, 0.5);
  }

  .auto-control-button:active {
    transform: scale(0.98);
  }

  /* Green when inactive (off) */
  .auto-control-button.inactive {
    background: linear-gradient(180deg, rgba(76, 175, 80, 0.9), rgba(46, 125, 50, 0.95));
    border-color: #4caf50;
  }

  /* Red when active (on) */
  .auto-control-button.active {
    background: linear-gradient(180deg, rgba(244, 67, 54, 0.9), rgba(183, 28, 28, 0.95));
    border-color: #f44336;
  }

  /* Merchant Selling UI */
  .merchant-ui {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 500px;
    max-height: 600px;
    background: rgba(21, 26, 60, 0.98);
    border: 3px solid #4a90e2;
    border-radius: 12px;
    display: none;
    flex-direction: column;
    z-index: 1000;
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.6);
  }

  .merchant-ui.visible {
    display: flex;
  }

  .merchant-ui__header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 20px;
    border-bottom: 2px solid #4a90e2;
  }

  .merchant-ui__title {
    font-size: 24px;
    font-weight: 700;
    color: #fff;
    text-transform: uppercase;
    letter-spacing: 1px;
  }

  .merchant-ui__close {
    width: 32px;
    height: 32px;
    background: rgba(244, 67, 54, 0.8);
    border: 2px solid #f44336;
    border-radius: 6px;
    color: #fff;
    font-size: 20px;
    font-weight: 700;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.2s ease;
  }

  .merchant-ui__close:hover {
    background: rgba(244, 67, 54, 1);
    transform: scale(1.1);
  }

  .merchant-ui__content {
    flex: 1;
    overflow-y: auto;
    padding: 10px;
    max-height: 450px;
  }

  .merchant-ui__ore-item {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 12px 15px;
    margin: 8px 0;
    background: rgba(30, 40, 80, 0.8);
    border: 2px solid #4a90e2;
    border-radius: 8px;
    min-height: 60px;
  }

  .merchant-ui__ore-info {
    flex: 1;
    display: flex;
    flex-direction: column;
    gap: 4px;
  }

  .merchant-ui__ore-name {
    font-size: 18px;
    font-weight: 600;
    color: #fff;
  }

  .merchant-ui__ore-name.stone { color: #9e9e9e; }
  .merchant-ui__ore-name.coal { color: #424242; }
  .merchant-ui__ore-name.copper { color: #b87333; }
  .merchant-ui__ore-name.iron { color: #d4d4d4; }
  .merchant-ui__ore-name.silver { color: #c0c0c0; }
  .merchant-ui__ore-name.gold { color: #ffd700; }
  .merchant-ui__ore-name.platinum { color: #e5e4e2; }
  .merchant-ui__ore-name.titanium { color: #878681; }
  .merchant-ui__ore-name.emerald { color: #50c878; }
  .merchant-ui__ore-name.ruby { color: #e0115f; }
  .merchant-ui__ore-name.sapphire { color: #0f52ba; }
  .merchant-ui__ore-name.topaz { color: #ffc87c; }
  .merchant-ui__ore-name.diamond { color: #b9f2ff; }
  .merchant-ui__ore-name.mithrial { color: #9b59b6; }
  .merchant-ui__ore-name.adamantite { color: #4a90e2; }
  .merchant-ui__ore-name.cosmic { color: #ff00ff; }

  .merchant-ui__ore-quantity {
    font-size: 14px;
    color: #aaa;
  }

  .merchant-ui__ore-value {
    display: flex;
    align-items: center;
    gap: 8px;
    font-size: 16px;
    font-weight: 600;
    color: #ffd700;
    margin-right: 15px;
  }

  .merchant-ui__coin-icon {
    width: 20px;
    height: 20px;
    background: #ffd700;
    border-radius: 50%;
    display: inline-block;
  }

  .merchant-ui__sell-button {
    padding: 8px 16px;
    background: linear-gradient(180deg, rgba(76, 175, 80, 0.9), rgba(46, 125, 50, 0.95));
    border: 2px solid #4caf50;
    border-radius: 6px;
    color: #fff;
    font-size: 14px;
    font-weight: 700;
    cursor: pointer;
    transition: all 0.2s ease;
    text-transform: uppercase;
  }

  .merchant-ui__sell-button:hover {
    transform: scale(1.05);
    box-shadow: 0 4px 12px rgba(76, 175, 80, 0.4);
  }

  .merchant-ui__sell-button:active {
    transform: scale(0.98);
  }

  .merchant-ui__footer {
    padding: 15px 20px;
    border-top: 2px solid #4a90e2;
    display: flex;
    justify-content: center;
  }

  .merchant-ui__sell-all-button {
    padding: 12px 40px;
    background: linear-gradient(180deg, rgba(76, 175, 80, 0.9), rgba(46, 125, 50, 0.95));
    border: 3px solid #4caf50;
    border-radius: 8px;
    color: #fff;
    font-size: 18px;
    font-weight: 700;
    cursor: pointer;
    transition: all 0.2s ease;
    text-transform: uppercase;
    letter-spacing: 1px;
  }

  .merchant-ui__sell-all-button:hover {
    transform: scale(1.05);
    box-shadow: 0 6px 16px rgba(76, 175, 80, 0.5);
  }

  .merchant-ui__sell-all-button:active {
    transform: scale(0.98);
  }

  /* Scrollbar styling */
  .merchant-ui__content::-webkit-scrollbar {
    width: 8px;
  }

  .merchant-ui__content::-webkit-scrollbar-track {
    background: rgba(30, 40, 80, 0.5);
    border-radius: 4px;
  }

  .merchant-ui__content::-webkit-scrollbar-thumb {
    background: #4a90e2;
    border-radius: 4px;
  }

  .merchant-ui__content::-webkit-scrollbar-thumb:hover {
    background: #5aa0f2;
  }

  /* Mine Reset Upgrade UI */
  .mine-reset-upgrade-ui {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 400px;
    background: rgba(21, 26, 60, 0.98);
    border: 3px solid #4caf50;
    border-radius: 12px;
    display: none;
    flex-direction: column;
    z-index: 1000;
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.6);
  }

  .mine-reset-upgrade-ui.visible {
    display: flex;
  }

  .mine-reset-upgrade-ui__header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 20px;
    border-bottom: 2px solid #4caf50;
  }

  .mine-reset-upgrade-ui__title {
    font-size: 24px;
    font-weight: 700;
    color: #fff;
    text-transform: uppercase;
    letter-spacing: 1px;
  }

  .mine-reset-upgrade-ui__close {
    width: 32px;
    height: 32px;
    border: none;
    background: rgba(244, 67, 54, 0.8);
    color: #fff;
    font-size: 24px;
    font-weight: 700;
    border-radius: 50%;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.2s ease;
    line-height: 1;
  }

  .mine-reset-upgrade-ui__close:hover {
    background: rgba(244, 67, 54, 1);
    transform: scale(1.1);
  }

  .mine-reset-upgrade-ui__body {
    padding: 30px;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 20px;
  }

  .mine-reset-upgrade-ui__description {
    font-size: 16px;
    color: #fff;
    text-align: center;
    line-height: 1.5;
  }

  .mine-reset-upgrade-ui__button-container {
    display: flex;
    justify-content: center;
    width: 100%;
  }

  .mine-reset-upgrade-ui__button {
    padding: 18px 40px;
    border-radius: 12px;
    border: 3px solid #4caf50;
    background: linear-gradient(180deg, rgba(76, 175, 80, 0.9), rgba(46, 125, 50, 0.95));
    color: #fff;
    font-size: 24px;
    font-weight: 800;
    text-transform: uppercase;
    letter-spacing: 2px;
    cursor: pointer;
    transition: all 0.2s ease;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
    min-width: 200px;
    pointer-events: auto;
  }

  .mine-reset-upgrade-ui__button:hover:not(.disabled):not(.bought) {
    transform: scale(1.05);
    box-shadow: 0 6px 16px rgba(76, 175, 80, 0.5);
    background: linear-gradient(180deg, rgba(96, 195, 100, 0.95), rgba(66, 145, 70, 1));
  }

  .mine-reset-upgrade-ui__button:active:not(.disabled):not(.bought) {
    transform: scale(0.98);
  }

  .mine-reset-upgrade-ui__button.disabled {
    opacity: 0.5;
    cursor: not-allowed;
    filter: grayscale(0.5);
    background: linear-gradient(180deg, rgba(100, 100, 100, 0.9), rgba(70, 70, 70, 0.95));
    border-color: #666;
  }

  .mine-reset-upgrade-ui__button.bought {
    opacity: 0.5;
    cursor: not-allowed;
    filter: grayscale(0.8);
    background: linear-gradient(180deg, rgba(100, 100, 100, 0.9), rgba(70, 70, 70, 0.95));
    border-color: #666;
    pointer-events: none;
  }

  .mine-reset-upgrade-ui__button.bought:hover {
    transform: none !important;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4) !important;
    background: linear-gradient(180deg, rgba(100, 100, 100, 0.9), rgba(70, 70, 70, 0.95)) !important;
  }

  .mine-reset-upgrade-ui__button-text {
    display: block;
    text-shadow: 
      -1px -1px 0 #000,
      1px -1px 0 #000,
      -1px 1px 0 #000,
      1px 1px 0 #000;
  }

  .mine-reset-upgrade-ui__status {
    font-size: 14px;
    text-align: center;
    padding: 10px;
    border-radius: 8px;
    min-height: 20px;
  }

  .mine-reset-upgrade-ui__status--can-afford {
    color: #4caf50;
  }

  .mine-reset-upgrade-ui__status--cannot-afford {
    color: #f44336;
  }

  .mine-reset-upgrade-ui__status--bought {
    color: #4caf50;
    font-weight: 700;
  }

  /* Gem Trader Upgrades UI */
  .gem-trader-ui {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 600px;
    max-height: 700px;
    background: rgba(21, 26, 60, 0.98);
    border: 3px solid #4caf50;
    border-radius: 12px;
    display: none;
    flex-direction: column;
    z-index: 1000;
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.6);
  }

  .gem-trader-ui.visible {
    display: flex;
  }

  .gem-trader-ui__header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 20px;
    border-bottom: 2px solid #4caf50;
  }

  .gem-trader-ui__help-button {
    width: 32px;
    height: 32px;
    border: none;
    background: rgba(76, 175, 80, 0.8);
    color: #fff;
    font-size: 20px;
    font-weight: 700;
    border-radius: 4px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.2s ease;
  }

  .gem-trader-ui__help-button:hover {
    background: rgba(76, 175, 80, 1);
    transform: scale(1.05);
  }

  .gem-trader-ui__title {
    font-size: 28px;
    font-weight: 700;
    color: #fff;
    text-transform: uppercase;
    letter-spacing: 1px;
    text-shadow: -1px -1px 0 rgba(0, 0, 0, 0.5),
      1px -1px 0 rgba(0, 0, 0, 0.5),
      -1px 1px 0 rgba(0, 0, 0, 0.5),
      1px 1px 0 rgba(0, 0, 0, 0.5);
  }

  .gem-trader-ui__close {
    width: 32px;
    height: 32px;
    border: none;
    background: rgba(244, 67, 54, 0.8);
    color: #fff;
    font-size: 24px;
    font-weight: 700;
    border-radius: 50%;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.2s ease;
    line-height: 1;
  }

  .gem-trader-ui__close:hover {
    background: rgba(244, 67, 54, 1);
    transform: scale(1.1);
  }

  .gem-trader-ui__content {
    padding: 20px;
    overflow-y: auto;
    display: flex;
    flex-direction: column;
    gap: 16px;
  }

  .gem-trader-ui__upgrade-item {
    display: flex;
    align-items: center;
    gap: 16px;
    padding: 16px;
    background: rgba(30, 35, 70, 0.8);
    border-radius: 8px;
    border: 2px solid rgba(76, 175, 80, 0.3);
  }

  .gem-trader-ui__icon-container {
    position: relative;
    width: 64px;
    height: 64px;
    flex-shrink: 0;
  }

  .gem-trader-ui__icon {
    font-size: 48px;
    width: 64px;
    height: 64px;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .gem-trader-ui__arrow-overlay {
    position: absolute;
    top: -4px;
    right: -4px;
    font-size: 16px;
    color: #ff9800;
    font-weight: 700;
    text-shadow: -1px -1px 0 rgba(0, 0, 0, 0.8),
      1px -1px 0 rgba(0, 0, 0, 0.8),
      -1px 1px 0 rgba(0, 0, 0, 0.8),
      1px 1px 0 rgba(0, 0, 0, 0.8);
  }

  .gem-trader-ui__details {
    flex: 1;
    display: flex;
    flex-direction: column;
    gap: 8px;
  }

  .gem-trader-ui__upgrade-title {
    font-size: 20px;
    font-weight: 700;
    color: #fff;
  }

  .gem-trader-ui__effect {
    font-size: 16px;
    color: #4caf50;
    font-weight: 600;
  }

  .gem-trader-ui__level-cost-container {
    display: flex;
    flex-direction: column;
    align-items: flex-end;
    gap: 4px;
  }

  .gem-trader-ui__level-progress {
    display: flex;
    align-items: center;
    gap: 4px;
    font-size: 14px;
    color: #4caf50;
    font-weight: 600;
  }

  .gem-trader-ui__level-arrow {
    color: #ff9800;
  }

  .gem-trader-ui__cost {
    display: flex;
    align-items: center;
    gap: 4px;
    font-size: 14px;
    color: #4caf50;
    font-weight: 600;
  }

  .gem-trader-ui__gem-icon {
    font-size: 16px;
  }

  .gem-trader-ui__upgrade-button {
    width: 48px;
    height: 48px;
    border: none;
    border-radius: 8px;
    font-size: 28px;
    font-weight: 700;
    color: #fff;
    cursor: pointer;
    transition: all 0.2s ease;
    display: flex;
    align-items: center;
    justify-content: center;
    flex-shrink: 0;
  }

  .gem-trader-ui__upgrade-button.can-afford {
    background: rgba(76, 175, 80, 0.9);
    border: 2px solid #4caf50;
  }

  .gem-trader-ui__upgrade-button.can-afford:hover {
    background: rgba(76, 175, 80, 1);
    transform: scale(1.1);
  }

  .gem-trader-ui__upgrade-button.cannot-afford {
    background: rgba(244, 67, 54, 0.7);
    border: 2px solid #f44336;
    cursor: not-allowed;
    opacity: 0.6;
  }

  .gem-trader-ui__upgrade-button:disabled {
    cursor: not-allowed;
    opacity: 0.6;
  }

  .gem-trader-ui__content::-webkit-scrollbar {
    width: 8px;
  }

  .gem-trader-ui__content::-webkit-scrollbar-track {
    background: rgba(0, 0, 0, 0.2);
    border-radius: 4px;
  }

  .gem-trader-ui__content::-webkit-scrollbar-thumb {
    background: rgba(76, 175, 80, 0.6);
    border-radius: 4px;
  }

  .gem-trader-ui__content::-webkit-scrollbar-thumb:hover {
    background: rgba(76, 175, 80, 0.8);
  }

</style>