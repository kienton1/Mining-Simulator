/**
 * Calculate Pet Model Heights
 *
 * This script reads all pet model glTF files and calculates their bounding box heights.
 * Run with: npx tsx scripts/calculate-pet-heights.ts
 *
 * Note: Requires @gltf-transform/core package:
 *   npm install @gltf-transform/core
 */

import * as fs from 'fs';
import * as path from 'path';
import { NodeIO } from '@gltf-transform/core';

interface BoundingBox {
  min: [number, number, number];
  max: [number, number, number];
}

/**
 * Calculate bounding box for a glTF document
 */
async function calculateBoundingBox(filePath: string): Promise<BoundingBox | null> {
  try {
    const io = new NodeIO();
    const document = await io.read(filePath);
    const root = document.getRoot();

    let minX = Infinity, minY = Infinity, minZ = Infinity;
    let maxX = -Infinity, maxY = -Infinity, maxZ = -Infinity;
    let hasVertices = false;

    // Iterate through all meshes
    for (const mesh of root.listMeshes()) {
      for (const primitive of mesh.listPrimitives()) {
        const positionAccessor = primitive.getAttribute('POSITION');
        if (!positionAccessor) continue;

        const positions = positionAccessor.getArray();
        if (!positions) continue;

        // Process each vertex (3 components per vertex: x, y, z)
        for (let i = 0; i < positions.length; i += 3) {
          const x = positions[i];
          const y = positions[i + 1];
          const z = positions[i + 2];

          minX = Math.min(minX, x);
          minY = Math.min(minY, y);
          minZ = Math.min(minZ, z);
          maxX = Math.max(maxX, x);
          maxY = Math.max(maxY, y);
          maxZ = Math.max(maxZ, z);
          hasVertices = true;
        }
      }
    }

    if (!hasVertices) {
      return null;
    }

    return {
      min: [minX, minY, minZ],
      max: [maxX, maxY, maxZ],
    };
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error);
    return null;
  }
}

async function main() {
  const petsDir = path.join(__dirname, '../assets/models/Pets');

  // Find all pet model directories
  const modelFolders = fs.readdirSync(petsDir)
    .filter((name) => {
      const fullPath = path.join(petsDir, name);
      return fs.statSync(fullPath).isDirectory();
    });

  console.log(`Found ${modelFolders.length} pet model folders\n`);

  const heights: Record<string, number> = {};

  for (const folder of modelFolders) {
    const folderPath = path.join(petsDir, folder);
    const files = fs.readdirSync(folderPath);
    const gltfFile = files.find((f) => f.endsWith('.gltf') || f.endsWith('.glb'));

    if (!gltfFile) {
      console.log(`No glTF file found in ${folder}`);
      continue;
    }

    const gltfPath = path.join(folderPath, gltfFile);
    const bbox = await calculateBoundingBox(gltfPath);

    if (bbox) {
      const height = bbox.max[1] - bbox.min[1];
      heights[folder] = parseFloat(height.toFixed(2));
      console.log(`${folder}: height = ${height.toFixed(2)} units`);
    } else {
      console.log(`${folder}: Could not calculate height`);
    }
  }

  console.log('\n=== PET_MODEL_HEIGHTS TypeScript Map ===\n');
  console.log('export const PET_MODEL_HEIGHTS: Record<string, number> = {');

  // Sort alphabetically
  const sortedFolders = Object.keys(heights).sort();
  for (const folder of sortedFolders) {
    console.log(`  '${folder}': ${heights[folder]},`);
  }

  console.log('};');

  // Write to a file
  const outputPath = path.join(__dirname, 'pet-heights-output.ts');
  const output = `// Generated by calculate-pet-heights.ts
// Run: npx tsx scripts/calculate-pet-heights.ts

export const PET_MODEL_HEIGHTS: Record<string, number> = {
${sortedFolders.map((folder) => `  '${folder}': ${heights[folder]},`).join('\n')}
};
`;

  fs.writeFileSync(outputPath, output);
  console.log(`\nOutput written to ${outputPath}`);
}

main().catch(console.error);
